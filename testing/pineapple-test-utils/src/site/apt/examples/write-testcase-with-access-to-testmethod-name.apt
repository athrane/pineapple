 ------
 How-to: Write test cases that requires access to the name of the test method  
 ------
 Allan Thrane Andersen
 ------
 November 2009

~~ NOTE: For help with the syntax of this file, see:
~~ http://maven.apache.org/guides/mini/guide-apt-format.html

How-to: Write test cases that requires access to the name of the test method

	If your test case needs to know the name of the currently executing test method, 
	then the Pineapple test utilities contains a Spring <<TestExecutionListener>> 
	implementation, which can be invoke to return the name of the currently executing 
	test method.
	
	To write unit tests that requires disk access follow these steps:
	
	* Add Spring-test Maven test dependencies to the project
	
	* Write the test class		
	
	[]		 

* Add Spring-test Maven dependency to the project	
	  	
	The Spring-test jar gives access to:
	
	* The <<<@TestExecutionListeners>>> annotation.
	
	* The <<<@ContextConfiguration>>> annotation.
	
	[]	
	 	
	To use the Spring framework test facilities, add the Maven dependency to 
	the project POM:

+-----
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>org.springframework.test</artifactId>
	<scope>test</scope>		
  </dependency>					
+-----

	Version information is located in the <<<pineapple-project/pom.xml>>>. The dependency
	is scoped as <<<test>>> as it should only be available in the test phase.
	
	If the projects dones't have other Spring dependecies then the Spring test framework requires these two
	additional dependencies:

+-----
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>org.springframework.beans</artifactId>
	<scope>test</scope>		
  </dependency>					
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>org.springframework.context</artifactId>
	<scope>test</scope>		
  </dependency>					  
+-----
	
	
* Write the JUnit test class

	Create the JUnit test class which should contain the tests which needs access to 
	the test methods.  			

** Configure the class to be run with the Spring JUnit class runner

	Annotate the class with the <<<@RunWith( SpringJUnit4ClassRunner.class )>>> 
	Spring annotation to configure the class to be run with the Spring JUnit class 
	runner:
		
	* <<<@RunWith( SpringJUnit4ClassRunner.class )>>> to configure class to be run with Spring Junit test runner.	

** Configure the class to be run with the proper context configuration
	
	Annotate the class with the <<<@ContextConfiguration( locations = { "/some-app-config-config.xml" } )>>> 
	Spring annotation to configure the Spring JUnit class runner to load the 
	application context from the designated location(s): 	
	
	* <<<@ContextConfiguration( locations = { "/com.alpha.pineapple.some.component-config.xml" } )>>>
	to load the application context from the src/main/resources directory in some project 
		
** Configure the class to be run with TestExecutionListener which provides access to the test method name

	Annotate the class with the <<<@TestExecutionListeners( NameAwareTestExecutionListener.class )>>> 
	Spring annotation to configure the Spring test runner to use the <<<DirectoryTestExecutionListener>>>
	class during test execution.
		
*** Accessing the test method name

	The name of the current test method test can be looked up from a test
	method using the static method <<<NameAwareTestExecutionListener.getCurrentTestMethodName()>>>.
	
	The method can be invoked in the <<<setUp()>>> for test class, as shown in the example below. 
			
** Configure the class to be run with the default Spring <<<TestExecutionListener>>> implementations

	Spring 3.0 contains three default <<<TestExecutionListener>>> implementation's
	which needs to be configured additionally with the <<<@TestExecutionListeners>>>
	if their functionality should be enabled:
	
	* <<<DependencyInjectionTestExecutionListener>>> which provides support for dependency 
	injection and initialization of test instances. 
	
	* <<<DirtiesContextTestExecutionListener>>> used with the <<<@DirtiesContext>>> 
	annotation which should if the test modifies the context.
	
	* <<<TransactionalTestExecutionListener>>> which provides support for executing 
	tests within transactions by using the Spring transactional annotation.
	
	[]	 

	{{{http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/ch09s03.html#testcontext-framework}Link to the Spring 3.0 documentation about the default <<<TestExecutionListener>>> implementations.}}
	
	<<Please notice:>> if the test case is a integration test then the 
	<<<DependencyInjectionTestExecutionListener>>> should used to enable
	the dependency injection.   			
			
					
* Examples

** Example: Running the test with DirectoryTestExecutionListener only 
					
	Dependency injection will be disabled in this example.				
					
+-----	

@RunWith( SpringJUnit4ClassRunner.class )
@TestExecutionListeners( DirectoryTestExecutionListener.class )
@ContextConfiguration( locations = { "/com.alpha.pineapple.some.component-config.xml" } )
public class SomeTest {
    
    /**
     * Current test method name.
     */
	String testName;
	
	@Before
	public void setUp() throws Exception {
		
		// get the test directory
		testName = NameAwareTestExecutionListener.getCurrentTestMethodName();				
	}

	@After
	public void tearDown() throws Exception {
		
		testName = null;
	}

	@Test
	public void testSomething() {
				
		// using the method name
		System.out.println( testName);						
	
		// remaining test logic....		
	}
	
}

+-----
	
** Example: Running the test with DirectoryTestExecutionListener and DependencyInjectionTestExecutionListener
					
	Dependency injection will be enabled in this example.					
		
+-----	

@RunWith( SpringJUnit4ClassRunner.class )
@TestExecutionListeners( {DirectoryTestExecutionListener.class, DependencyInjectionTestExecutionListener.class} )
@ContextConfiguration( locations = { "/com.alpha.pineapple.some.component-config.xml" } )
public class SomeTest {
    
    /**
     * Current test method name.
     */
	String testName;
	
	@Before
	public void setUp() throws Exception {
		
		// get the test directory
		testName = NameAwareTestExecutionListener.getCurrentTestMethodName();				
	}

	@After
	public void tearDown() throws Exception {
		
		testName = null;
	}

	@Test
	public void testSomething() {
				
		// using the method name
		System.out.println( testName);						
	
		// remaining test logic....		
	}
	
}

+-----
		