<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 13 Apr 2017
 | Rendered using Apache Maven Fluido Skin 1.3.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Allan Thrane Andersen" />
    <meta name="Date-Revision-yyyymmdd" content="20170413" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Pineapple WebLogic JMX plugin - Development documentation - Implementation</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.3.0.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />

      
    <script type="text/javascript" src="../js/apache-maven-fluido-1.3.0.min.js"></script>

    
            </head>
        <body class="topBarDisabled">
          
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Pineapple WebLogic JMX plugin</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                              <li class="">
                    <a href="../../../index.html" title="Pineapple Home">
        Pineapple Home</a>
        </li>
      <li class="divider ">/</li>
            <li class="">
                    <a href="../../" title="Pineapple modules">
        Pineapple modules</a>
        </li>
      <li class="divider ">/</li>
            <li class="">
                    <a href="../" title="Pineapple WebLogic JMX plugin">
        Pineapple WebLogic JMX plugin</a>
        </li>
      <li class="divider ">/</li>
        <li class="">Development documentation - Implementation</li>
        
                
                    
                  <li id="publishDate" class="pull-right">Last Published: 13 Apr 2017</li> 
            
                            </ul>
      </div>

                  
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Project Overview</li>
                                
      <li>
    
                          <a href="../../../index.html" title="Home">
          <i class="none"></i>
        Home</a>
            </li>
                  
      <li>
    
                          <a href="../../../usage/installation.html" title="Installation">
          <i class="none"></i>
        Installation</a>
            </li>
                  
      <li>
    
                          <a href="../../../usage/index.html" title="For Users">
          <i class="none"></i>
        For Users</a>
            </li>
                  
      <li>
    
                          <a href="../../../development/index.html" title="For Developers">
          <i class="none"></i>
        For Developers</a>
            </li>
                  
      <li>
    
                          <a href="../../../usage/terms.html" title="Terms and Conditions">
          <i class="none"></i>
        Terms and Conditions</a>
            </li>
                              <li class="nav-header">Clients</li>
                                
      <li>
    
                          <a href="../../../pineapple-applications/pineapple-web-application/pineapple-standalone-web-client/index.html" title="Standalone Web Application">
          <i class="none"></i>
        Standalone Web Application</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-applications/pineapple-web-application/pineapple-web-application-war/index.html" title="Deployable Web Application">
          <i class="none"></i>
        Deployable Web Application</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-applications/pineapple-maven-plugin/index.html" title="Maven Plugin">
          <i class="none"></i>
        Maven Plugin</a>
            </li>
                              <li class="nav-header">Plugins</li>
                                
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-agent-plugin/index.html" title="Agent">
          <i class="none"></i>
        Agent</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-composite-execution-plugin/index.html" title="Composite Execution">
          <i class="none"></i>
        Composite Execution</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-ssh-plugin/index.html" title="SSH">
          <i class="none"></i>
        SSH</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-docker-plugin/index.html" title="Docker">
          <i class="none"></i>
        Docker</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-modules/pineapple-infrastructure-test-plugin/index.html" title="Infrastructure Test">
          <i class="none"></i>
        Infrastructure Test</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-jrockit-installation-plugin/index.html" title="JRockit Installation">
          <i class="none"></i>
        JRockit Installation</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-fusion-middleware-installation-plugin/index.html" title="Fusion Middleware Installation">
          <i class="none"></i>
        Fusion Middleware Installation</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-weblogic-installation-plugin/index.html" title="WebLogic Installation">
          <i class="none"></i>
        WebLogic Installation</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-modules/pineapple-weblogic-deployment-plugin/index.html" title="WebLogic Deployment">
          <i class="none"></i>
        WebLogic Deployment</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-plugins/pineapple-weblogic-scripting-tool-plugin/index.html" title="WebLogic Scripting Tool (WLST)">
          <i class="none"></i>
        WebLogic Scripting Tool (WLST)</a>
            </li>
                  
      <li>
    
                          <a href="../../../pineapple-modules/pineapple-weblogic-jmx-plugin/index.html" title="WebLogic JMX">
          <i class="none"></i>
        WebLogic JMX</a>
            </li>
                              <li class="nav-header">API's</li>
                                
      <li>
    
                          <a href="../../../pineapple-applications/pineapple-web-application/pineapple-web-application-war/usage/rest.html" title="REST">
          <i class="none"></i>
        REST</a>
            </li>
                  
      <li>
    
                          <a href="../../../development/plugin-framework.html" title="Plugin Framework">
          <i class="none"></i>
        Plugin Framework</a>
            </li>
                              <li class="nav-header">Additional Information</li>
                                
      <li>
    
                          <a href="http://pineapplesoftware.blogspot.com" class="externalLink" title="The Pineapple Project Blog">
          <i class="none"></i>
        The Pineapple Project Blog</a>
            </li>
                  
      <li>
    
                          <a href="http://exceptiontrail.blogspot.com" class="externalLink" title="Pineapple Exception Trail Blog">
          <i class="none"></i>
        Pineapple Exception Trail Blog</a>
            </li>
                              <li class="nav-header">Project Tools</li>
                                
      <li>
    
                          <a href="https://bintray.com/pineapple/maven/com.alpha.pineapple" class="externalLink" title="Downloads">
          <i class="none"></i>
        Downloads</a>
            </li>
                  
      <li>
    
                          <a href="https://github.com/athrane/pineapple" class="externalLink" title="Source Code">
          <i class="none"></i>
        Source Code</a>
            </li>
                  
      <li>
    
                          <a href="https://github.com/athrane/pineapple/issues" class="externalLink" title="Issue Tracker">
          <i class="none"></i>
        Issue Tracker</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                        
      <li>
    
                          <a href="../project-info.html" title="Project Information">
          <i class="icon-chevron-right"></i>
        Project Information</a>
                  </li>
            </ul>
                
                    
                
          <hr class="divider" />

           <div id="poweredBy">
                   
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>

    
    <div class="g-plusone" data-href="http://maven.apache.org" data-size="tall" ></div>

                   <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                        
        <div id="bodyColumn"  class="span10" >
                                  
            <!-- NOTE: For help with the syntax of this file, see: --><!-- http://maven.apache.org/guides/mini/guide-apt-format.html --><div class="section">
<h2>Development documentation - Implementation<a name="Development_documentation_-_Implementation"></a></h2>
<p>The implementation contains these packages:</p>
<ul>
<li>Plugin class.</li>
<li>Session classes.</li>
<li>Operation classes.</li>
<li><a href="#Resolved_model_classes">Resolved model classes</a>.</li>
<li><a href="#Resolved_model_traversal_classes">Resolved model traversal classes</a>.</li>
<li><a href="#Resolved_model_traversal_strategy_classes">Resolved model traversal strategy classes</a>.</li>
<li><a href="#Resolved_model_building_classes">Resolved model building classes</a>.</li>
<li><a href="#Resolved_model_test_classes">Resolved model test classes</a>. </li>
<li><a href="#Commands">Commands</a>. </li>
<li><a href="#XMLBeans_model_access_classes">XMLBeans model access classes</a>.</li>
<li><a href="#MBeans_model_access_classes">MBeans model access classes</a>.</li>
<li><a href="#Generic_reflection_helper_classes">Generic reflection helper classes</a>.</li>
<li><a href="#Generic_JMX_helper_classes">Generic JMX helper classes</a>. </li></ul>
<div class="section">
<h3>Plugin class<a name="Plugin_class"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx</tt> is the root package of the plugin and contains the plugin class <tt>PluginImpl</tt>. </p></div>
<div class="section">
<h3>Constants <a name="Constants"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx</tt> is the root package an contains these constant classes:</p>
<ul>
<li><tt>WebLogicMBeanConstants</tt> implements WebLogic and JMX constants.</li>
<li><tt>WebLogicXmlBeanConstants</tt> implements WebLogic XMLBeans constants.</li></ul></div>
<div class="section">
<h3>Session classes<a name="Session_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.session</tt> contains the session classes for the plugin:</p>
<ul>
<li><tt>JMXSession</tt> extends the <tt>Session</tt> interface.</li>
<li><tt>WeblogicJMXEditSession</tt> extends the <tt>JMXSession</tt> interface.</li>
<li><tt>WeblogicJMXEditSessionImpl</tt> implements the <tt>WeblogicJMXEditSessionImpl</tt> interface and provides access to a WebLogic Edit Session.</li></ul></div>
<div class="section">
<h3>Operation classes<a name="Operation_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.operation</tt> contains the operation classes for the plugin.</p>
<p>The plugin implement these default operations: </p>
<ul>
<li><tt>CreateReport</tt> implements the operation <tt>deploy-configuration</tt>.</li>
<li><tt>DeployConfiguration</tt> implements the operation <tt>deploy-configuration</tt>. </li>
<li><tt>UndeployConfiguration</tt> implements the operation <tt>undeploy-configuration</tt>. </li>
<li><tt>TestOperation</tt> implements the operation <tt>test</tt>. </li></ul>
<div class="section">
<h4>Preparing the XMLBeans model for traversal <a name="Preparing_the_XMLBeans_model_for_traversal"></a></h4>
<p>The XMLBeans model must be stored in an <tt>ResolvedParticipant</tt> which is used during traversal. A resolved participant object contains three pieces of information: value, type and a name. </p>
<p>The value part of the participant is resolved as:</p>
<ul>
<li>When <tt>execute( Object content, Session session, ExecutionResult result )</tt> is invoked the <tt>content object</tt> contains a <tt>DomainDocument</tt> object. </li>
<li>The domain document object is type cast to <tt>DomainDocument</tt>.</li>
<li>The root object in the model, the domain object, of type <tt>DomainType</tt> is retrieved from the domain document. </li></ul>
<p>The type part of the participant is resolved as: </p>
<ul>
<li>Reading <tt>SchemaType</tt> from the the domain document.</li>
<li>Resolving the property named <i>Domain</i> from the schema type, which is returned as an <tt>SchemaProperty</tt>.</li>
<li>The schema property is stored as the type for the domain object.</li></ul>
<p>The name part of the participant is resolved as:</p>
<ul>
<li>The value of the <tt>name</tt> attribute of the domain object.</li></ul></div>
<div class="section">
<h4>Preparing the MBeans model for traversal<a name="Preparing_the_MBeans_model_for_traversal"></a></h4>
<p>The MBeans model must be stored in an <tt>ResolvedParticipant</tt> which is used during traversal. A resolved participant object contains three pieces of information: value, type and a name. </p>
<p>The value part of the participant is resolved as:</p>
<ul>
<li>The <tt>session</tt> argument is type cast to a <tt>WeblogicJMXEditSession</tt>.</li>
<li>The WebLogic Edit session is set into <i>edit mode</i>, at which point the <tt>DomainMBean</tt> for the current session is available. </li>
<li>The <tt>DomainMBean</tt> is obtained as a <tt>ObjectName</tt> which allows for standard JMX access to the MBeans model. </li></ul>
<p>The type part of the participant is resolved as: </p>
<ul>
<li>The type is resolved as <tt>ObjectName</tt>.</li></ul>
<p>The name part of the participant is resolved as:</p>
<ul>
<li>The value of the <tt>Name</tt> key property read from domain object name.</li></ul></div>
<div class="section">
<h4>Setting up the model traversal <a name="Setting_up_the_model_traversal"></a></h4>
<p>With two models ready for traversal the operation class prepares the traversal by:</p>
<ul>
<li>Create a <tt>ResolvedObject</tt> object which contains:
<ul>
<li>A primary resolved participant which contains the XMLBeans model as described above. </li>
<li>A secondary resolved participant which contains the MBeans model as described above. </li></ul></li>
<li>The operation is configured with the Spring bean <a href="#Configured_ModelTraversalDirector_instances">xmlBeansModelBuilder</a> which is an instance of the class <tt>ModelTraversalDirectorImpl</tt>. The traversal director directs the <b>building</b> of an resolved model from the two models. The traversal director uses the resolved model visitor <a href="#Model_building_algorithm_in_ResolvedModelBuilderVisitorImpl">ResolvedModelBuilderVisitorImpl</a> to build the resolved model. The traversal director completes initialization of the visitor by setting the session object which gives access to a JMX Edit Session in WebLogic.</li>
<li>The operation is configured with the Spring bean <a href="#Configured_ModelTraversalDirector_instances">xmlBeansModelTester</a> which is an instance of the class <tt>ModelTraversalDirectorImpl</tt>. The traversal director directs the <b>test</b> of an resolved model containing the two models. The traversal director uses the resolved model visitor <a href="#Model_test_algorithm_in_ResolvedModelTesterVisitorImpl">ResolvedModelTesterVisitorImpl</a> to test the resolved model. The traversal director completes initialization of the visitor by setting the session object which gives access to a JMX Edit Session in WebLogic.</li></ul>
<p>Finally the traversal is started. The pseudo code for the process looks like:</p>
<div class="source">
<pre>    // create resolved type at the root of the models
    ResolvedType resolvedRoot = ResolvedTypeImpl.createResolvedObject( NULL_PARENT, primary, secondary );                              

    // recursive traversal of the model
    builderDirector.traverse( resolvedRoot, result  );
    
    // recursive traversal of the model
    testDirector.traverse( resolvedRoot, result  );
    
</pre></div></div></div>
<div class="section">
<h3><a name="Resolved_model_classes">Resolved model classes</a></h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel</tt> contains classes which are used to store the result when two models are resolved against each other to locate the corresponding model entities which should be processed. A resolved model contains these types: </p>
<ul>
<li><tt>ResolvedType</tt> - defines a type which is resolved in each of the two traversed models. </li>
<li><tt>ResolvedTypeImpl</tt> - the default implementation of <tt>ResolvedType</tt> which contains a two model participants, one from each model which have been resolved. The <tt>ResolvedType</tt> is extended with specific sub types which the model participants can be resolved into:
<ul>
<li><tt>ResolvedObject</tt> - represents model entities resolved to object. </li>
<li><tt>ResolvedCollection</tt> - represents model entities resolved to a collection, which contains model entities of a type. A collection can be implemented different in the different models. The <tt>ResolvedCollection</tt> is used to represent both arrays and collection classes. </li>
<li><tt>ResolvedPrimitive</tt> - represents model entities resolved to a primitive, such as a integer, char, boolean and string.</li>
<li><tt>ResolvedEnum</tt> - represents model entities resolved to a enumerated type. </li>
<li><tt>UnresolvedType</tt> - represents unresolved type due to an exception. The exception is contained in both of the participants. </li></ul></li>
<li><tt>ResolvedParticipant</tt> - defines information about a entity from a single model. Used by <tt>ResolvedType</tt> which always contains two of these, one from each model.</li>
<li><tt>ResolvedParticipantImpl</tt> - default implementation of <tt>ResolvedParticipant</tt>.</li>
<li><tt>ResolvedParticipantStyle</tt> - extension of the <tt>org.apache.commons.lang.builder.ToStringStyle</tt> class which can output the content of an resolved participant on a single line.</li></ul>
<div class="section">
<h4>Creating resolved objects<a name="Creating_resolved_objects"></a></h4>
<p>Resolved object are created by <tt>ResolvedModelBuilderVisitorImpl</tt> during model construction. The builder visitor invokes the <tt>createResolvedType(..)</tt> method on its primary model resolver to create resolved model object:</p>
<div class="source">
<pre>
interface ModelResolver {

  ResolvedType createResolvedType(ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary);
 
  // remaining interface definition goes here.. 
}  

</pre></div>
<p>The primary model resolver for a model builder visitor is initialized using depedency injection based on the Spring configuration for a particular model visitor bean definition.</p>
<p>Implementations of the <tt>ModelResolver</tt> interface should create resolved type instances using the public factory methods on <tt>ResolvedTypeImpl</tt>: </p>
<div class="source">
<pre>
public static ResolvedType createResolvedType( ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary );
public static ResolvedObject createResolvedObject( Object primary, Object secondary );
public static ResolvedObject createResolvedObject( ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary );
public static ResolvedCollection createResolvedCollection( ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary );
public static ResolvedEnum createResolvedEnum( ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary );
public static ResolvedPrimitive createResolvedPrimitive( ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary );
public static ResolvedType createUnresolvedType(ResolvedType parent, Exception exception);

</pre></div>
<p>Resolved participants are created using the public factory methods on <tt>ResolvedParticipantImpl</tt>: </p>
<div class="source">
<pre>
public static ResolvedParticipant createSuccessfulResult( String name, Object type, Object value );
public static ResolvedParticipant createSuccessfulResult( String name, Object type, Object value, ValueState state );
public static ResolvedParticipant createUnsuccessfulResult( String name, Object type, Object value, Exception exception );

</pre></div></div></div>
<div class="section">
<h3><a name="Resolved_model_traversal_classes">Resolved model traversal classes</a> </h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel.traversal</tt> contains classes for traversal of models:</p>
<ul>
<li><tt>ResolvedModelVisitor</tt> - interface for visitor which can visit resolved model types.</li>
<li><tt>ModelTraversalDirector</tt> - interface for traversal of models. The traversal director supports parallel traversal of two models from a resolved root model node.</li>
<li><tt>PostOrderDirectorImpl</tt> - which implements the <tt>ModelTraversalDirector</tt> interface and supports postorder traversal of a resolved model. </li>
<li><tt>PreOrderDirectorImpl</tt> - which implements the <tt>ModelTraversalDirector</tt> interface and supports preorder traversal of a resolved model. </li></ul>
<div class="section">
<h4>Visiting resolved objects<a name="Visiting_resolved_objects"></a></h4>
<p>Resolved object can be visited by resolved model visitors, which implement the interface <tt>ResolvedModelVisitor</tt>:</p>
<div class="source">
<pre>public interface ResolvedModelVisitor
{
    public Object visit(ResolvedType resolvedType, ExecutionResult result);
    public Object visit(ResolvedObject resolvedObject, ExecutionResult result);
    public Object visit(ResolvedEnum resolvedEnum, ExecutionResult result);
    public Object visit(ResolvedCollection resolvedCollection, ExecutionResult result);
    public Object visit(ResolvedPrimitive resolvedPrimitive, ExecutionResult result);
    public Object visit(UnresolvedType unresolved, ExecutionResult result);
    
    public void setSession(Session session);
}       
</pre></div>
<p>The interface defines two type of methods:</p>
<ul>
<li><tt>setSession(Session session)</tt> which is used to configure the visitor with a Pineapple session object which enables the visitor to access a Pineapple resource if needed.</li>
<li><tt>visitXXX(..)</tt> methods which allow visitation of resolved model types. Implementations of the interface can choose to return an optional product which is produced by the visitor. The <tt>ExecutionResult</tt> argument contains a execution result which is passed on by the model traversal director. A visitor is free to ignore the argument or create child execution results which documents the execution the visitor:
<ul>
<li><tt>XmlBeansDescriptionGeneratorImpl</tt> is an example of an visitor which ignores the execution result.</li>
<li><tt>ResolvedModelBuilderVisitorImpl</tt> is an example of an visitor which creates child execution results to document the how the construction of the resolved model proceeds.</li></ul></li></ul></div>
<div class="section">
<h4>ModelTraversalDirector implementations<a name="ModelTraversalDirector_implementations"></a></h4>
<p>The <tt>PostOrderDirectorImpl</tt> class implements a postorder traversal of resolved model. Postorder is defined as:</p>
<ul>
<li>Visit the children of the current resolved object.</li>
<li>Visit the current resolved object.</li></ul>
<p>The <tt>PreOrderDirectorImpl</tt> class implements a preorder traversal of resolved model. Postorder is defined as:</p>
<ul>
<li>Visit the current resolved object.</li>
<li>Visit the children of the current resolved object.</li></ul>
<p>Constructor injection is used for dependencies which are used in multiple different configurations. Field injection is used for objects which are doesn't change, i.e. are static. These dependencies is configured using constructor injection: </p>
<ul>
<li>resolved model visitor - which is invoked with each visited resolved model node.</li>
<li>traversal strategy - which is used to determine whether traversal should continue on a resolved model node.</li>
<li>description generator - which is an <tt>ResolvedModelVisitor</tt> implementation capable of generating string descriptions of resolved objects. </li></ul></div>
<div class="section">
<h4><a name="Configured_ModelTraversalDirector_instances">Configured ModelTraversalDirector instances</a></h4>
<p>The configuration of the director implementations and their dependencies are configured in the plugin application context configuration file: <tt>src/main/resources/com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The application context configuration file for the plugin contains these director beans:</p>
<ul>
<li><tt>xmlBeansModelBuilder</tt> which can build a resolved model from an XMLBeans model and an MBeans model. The director is configured as an instance of <tt>PreOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>xmlBeansModelBuilderVisitor</tt> which constructs an resolved model from the visited model parts.</li>
<li><tt>traverseExplicitSetNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of at least one participant succeeded.</li>
<li><tt>xmlBeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li>
<li><tt>xmlBeansModelTester</tt> which can test a resolved model. The director is configured as an instance of <tt>PostOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>xmlBeansModelTesterVisitor</tt> which tests the content of an resolved model.</li>
<li><tt>traverseExplicitSetPrimaryNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of the primary participant succeeded.</li>
<li><tt>xmlBeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li>
<li><tt>mbeansModelCreator</tt> which can create MBeans in WebLogic from resolved model. The director is configured as an instance of <tt>PreOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>mbeansCreatorVisitor</tt> which creates MBeans from the content of an resolved model.</li>
<li><tt>traverseExplicitSetPrimaryNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of the primary participant succeeded.</li>
<li><tt>xmlBeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li>
<li><tt>mbeansModelDeletor</tt> which can delete MBeans in WebLogic from resolved model. The director is configured as an instance of <tt>PostOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>mbeansDeletorVisitor</tt> which deletes MBeans from the content of an resolved model.</li>
<li><tt>traverseExplicitSetPrimaryNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of the primary participant succeeded.</li>
<li><tt>xmlBeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li>
<li><tt>mbeansModelBuilder</tt> which can build a resolved model from an XMLBeans model and an MBeans model. The director is configured as an instance of <tt>PreOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>xmlBeansModelBuilderVisitor</tt> which constructs an resolved model from the visited model parts.</li>
<li><tt>traverseExplicitSetSecondaryNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of the secondary participant succeeded.</li>
<li><tt>mbeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li>
<li><tt>mbeansReportCreator</tt> which can build a resolved model from an XMLBeans model and an MBeans model. The director is configured as an instance of <tt>PostOrderDirectorImpl</tt> with the dependencies:
<ul>
<li><tt>resolvedModelReportVisitor</tt> which echo the content of the secondary participant and thus creating a report of the MBeans model.</li>
<li><tt>traverseExplicitSetSecondaryNodesStrategy</tt> which directs the traversal to only visit resolved model nodes, where resolution of the secondary participant succeeded.</li>
<li><tt>mbeansDescriptionGenerator</tt> which constructs an description of an visited resolved model node.</li></ul></li></ul></div>
<div class="section">
<h4>Traversal algorithm in ModelTraversalDirectorImpl<a name="Traversal_algorithm_in_ModelTraversalDirectorImpl"></a></h4>
<p>The director implements a recursive traversal. The important method is:</p>
<div class="source">
<pre>    public void traverse (ResolvedType type, ExecutionResult result) throws Exception;  
</pre></div>
<p>which implements the algorithm:</p>
<ol style="list-style-type: decimal">
<li>If <tt>strategy.continueTraversal( type ))</tt> returns <tt>false</tt> then the traversal is considered completed and then method returns.</li>
<li>Visit the resolved type <tt>type</tt> with the configured vistitor by invoking <tt>type.accept(visitor, result)</tt>: 
<ol style="list-style-type: decimal">
<li>The <tt>accept(..)</tt> method invoked the appropiate <tt>visit(ResolvedType..or subtype, result)</tt> method on the visitor. </li>
<li>The visitor does its stuff.</li>
<li>The visitor creates a child <tt>ExecutionResult</tt> from the <tt>result</tt> argument, which describes the traversal of the resolved type <tt>type</tt>. </li>
<li>The visitor returns the child result. </li></ol></li>
<li>Iterate over the children from from the resolved type <tt>type</tt>:
<ol style="list-style-type: decimal">
<li>Invoke <tt>traverse ( child, childResult )</tt>.</li></ol></li>
<li>If the child result isn't <i>executing</i> then return.</li>
<li>Otherwise compute the state of the child result. </li></ol></div></div>
<div class="section">
<h3><a name="Resolved_model_traversal_strategy_classes">Resolved model traversal strategy classes</a> </h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel.traversal.strategy</tt> contains classes which implement traversal strategies:</p>
<ul>
<li><tt>TraversalStrategy</tt> - interface for controlling traversals, implements a strategy which decides how the traversal is executed.</li>
<li><tt>TraverseExplicitSetPrimaryNodesImpl</tt> - implements the <b>explicit nodes only</b> strategy which only traverses nodes which are explicit defined in the primary model.</li>
<li><tt>TraverseAllNodesImpl</tt> - implements the <b>traverse all nodes</b> strategy which traverse any object/attribute that the traversal director can resolve from the type system (schema) of the primary model.</li></ul>
<p>Intended use for the strategies:</p>
<ul>
<li><tt>TraverseExplicitSetPrimaryNodesImpl</tt> is intented to be used udring creation of a resolved model which only contains model nodes which are explicit defined in the primary model. </li>
<li><tt>TraverseAllNodesImpl</tt> is intented to be used.... </li></ul>
<div class="section">
<h4>Explicit set primary nodes only strategy<a name="Explicit_set_primary_nodes_only_strategy"></a></h4>
<p>A node is traversed if:</p>
<ul>
<li>Value state of primary attribute is SET. </li></ul></div>
<div class="section">
<h4>All nodes strategy <a name="All_nodes_strategy"></a></h4>
<p>A node is always traversed. </p></div></div>
<div class="section">
<h3><a name="Resolved_model_building_classes">Resolved model building classes</a></h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel.traversal</tt> contains classes for building resolved models:</p>
<ul>
<li><tt>ModelResolver</tt> - interface for resolution of model entities. </li>
<li><tt>ModelResolutionFailedException</tt> - exception class used to signal errors during resolution of model entities. </li>
<li><tt>ResolvedModelBuilderVisitorImpl</tt> - which implements the <tt>ResolvedModelVisitor</tt> interface can build a resolved model from the contents of two models. </li></ul>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.model.xmlbeans</tt> contains classes which participates in traversal of models with the purpose of building a resolved model:</p>
<ul>
<li><tt>XmlBeansDescriptionGeneratorImpl</tt> - implementation of the interface <tt>ResolvedModelVisitor</tt> which can create a description of an resolved model node.</li></ul>
<div class="section">
<h4>ResolvedModelBuilderVisitorImpl <a name="ResolvedModelBuilderVisitorImpl"></a></h4>
<p>Constructor injection is used for dependencies which are used in multiple different configurations. Field injection is used for objects which are doesn't change, i.e. are static. These dependencies is configured using constructor injection: </p>
<ul>
<li>primary model resolver - which is used to resolved model entitiies from the primary model.</li>
<li>secondary model resolver - which is used to resolved model entitiies from the secondary model.</li></ul></div>
<div class="section">
<h4>Configured ResolvedModelBuilderVisitorImpl instance<a name="Configured_ResolvedModelBuilderVisitorImpl_instance"></a></h4>
<p>The configuration of the model builder and its dependencies are configured in the plugin application context configuration file: <tt>src/main/resources/com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The application context configuration file for the plugin contains the builder bean:</p>
<ul>
<li><tt>xmlBeansModelBuilderVisitor</tt> which can build a resolved model from an XMLBeans model and an MBeans model. The builder is configured with:
<ul>
<li><tt>xmlBeansModelResolver</tt> which resolves model entities form an XMLBeans model.</li>
<li><tt>mbeansModelResolver</tt> which resolves model entities form an MBeans model.</li></ul></li></ul></div>
<div class="section">
<h4><a name="Model_building_algorithm_in_ResolvedModelBuilderVisitorImpl">Model building algorithm in ResolvedModelBuilderVisitorImpl</a> </h4>
<p>The visitor builds a resolved model by adding new child model node to each resolved model node which is it invoked with. The interface defines visitiation of these resolved types:</p>
<div class="source">
<pre>public interface ResolvedModelVisitor
{
    public void visit(ResolvedType resolvedType, ExecutionResult result);
    public void visit(ResolvedObject resolvedObject, ExecutionResult result);
    public void visit(ResolvedEnum resolvedEnum, ExecutionResult result);
    public void visit(ResolvedCollection resolvedCollection, ExecutionResult result);
    public void visit(ResolvedPrimitive resolvedPrimitive, ExecutionResult result);
    public void visit(UnresolvedType unresolved, ExecutionResult result);
    
    // additional methods...
}       
</pre></div>
<p>The next sub sections describes the algorithm for building new resolved model parts when the visitor is visiting an already resolved model object. <b>The central part of the algorithm is the invocation of the method createResolvedType(..) on the primary resolver which creates a new resolved model part of the correct type.</b> The algorithm for resolution of a new resolved model part from an XMLBeans based model is implemented in the <a href="#Creation_of_resolved_model_ojects_during_model_building">XmlBeansModelResolvedImpl.createResolvedType(..)</a> method. </p>
<div class="section">
<h5>Model construction from <tt>ResolvedType</tt><a name="Model_construction_from_ResolvedType"></a></h5>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedObject</tt> <a name="Model_construction_from_ResolvedObject"></a></h5>
<p>The algorithm for construction of the model from a <tt>ResolvedObject</tt> is:</p>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Resolve attribute names from primary participant. </li>
<li>Resolve attribute names from primary participant (using the primary resolver object). </li>
<li>Iterate over the set of names: 
<ol style="list-style-type: decimal">
<li>Resolve attribute from primary participant, using the current attribute name (using the primary resolver object). </li>
<li>If resolution fails then skip to next attribute name.</li>
<li>Resolve attribute from secondary participant, using the current attribute name (using the secondary resolver object). </li>
<li>Create a new child resolved object by invoking the method <tt>createResolvedType(..)</tt> on the primary resolver with the two resolved attributes as arguments. It is the responsibility of the primary resolver to determine the actual type of the resolved object by analyzing the arguments. </li>
<li>Add the child resolved object as a child to the <tt>ResolvedObject</tt>.</li></ol></li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedEnum</tt> <a name="Model_construction_from_ResolvedEnum"></a></h5>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedCollection</tt> <a name="Model_construction_from_ResolvedCollection"></a></h5>
<p>The algorithm for construction of the model from a <tt>ResolvedCollection</tt> is:</p>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Resolve the value (which is an collection) of the primary participant into an HashMap which contains an <tt>ResolvedParticipant</tt> for each entry in the collection.</li>
<li>Resolve the value (which is an collection) of the secondary participant into an HashMap which contains an <tt>ResolvedParticipant</tt> for each entry in the collection.</li>
<li>Create a combined key set which is a union of the keys from the two resolved collections (from step 3+4). </li>
<li>Iterate over the keys in the combined key set.
<ol style="list-style-type: decimal">
<li>Look up the resolved participant in the map with the primary participant values. If the value isn't defined in the map then a unsuccessful resolved object is created which describes the missing primary value as cause for the problem. The created resolved object contains a valid id and type. The value state is set to FAILED and the valus is null. </li>
<li>Look up the resolved participant in the map with the secondary participant values. If the value isn't defined in the map then a unsuccessful resolved object is created which describes the missing secondary value as cause for the problem. The created resolved object contains a valid id and type. The value state is set to FAILED and the valus is null. </li>
<li>Create a new child resolved object from the resolved participants:
<ol style="list-style-type: decimal">
<li>If the primary resolved participant was resolved successfully then create a new child resolved object by invoking the method <tt>createResolvedType(..)</tt> on the primary resolver with the two resolved participants as arguments. It is the responsibility of the primary resolver to determine the actual type of the resolved object by analyzing the arguments. Skip to step 6.4. Note: this case also handles the case where the secondary participant wasn't resolved successfully.</li>
<li>If the secondary resolved participant was resolved successfully then create a new child resolved object by invoking the method <tt>createResolvedType(..)</tt> on the secondary resolver with the two resolved participants as arguments. It is the responsibility of the secondary resolver to determine the actual type of the resolved object by analyzing the arguments. Skip to step 6.4. </li>
<li>If neither participants was resolved successfully then create a new child resolved object of the type <tt>UnresolvedType</tt> to signal the resolution failed for both participants.</li></ol></li>
<li>Add the child resolved object as a child to the <tt>ResolvedCollection</tt>.</li></ol></li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedPrimitive</tt> <a name="Model_construction_from_ResolvedPrimitive"></a></h5>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>UnresolvedType</tt> <a name="Model_construction_from_UnresolvedType"></a></h5>
<ol style="list-style-type: decimal">
<li>Create description of the resolved object using the description generator. </li>
<li>Create execution result which describes contruction of the resolved model node. </li>
<li>Return the execution result.</li></ol></div></div>
<div class="section">
<h4>XmlBeansDescriptionGeneratorImpl<a name="XmlBeansDescriptionGeneratorImpl"></a></h4>
<p>This class has no injected dependencies.</p></div>
<div class="section">
<h4>Configured XmlBeansDescriptionGeneratorImpl instance<a name="Configured_XmlBeansDescriptionGeneratorImpl_instance"></a></h4>
<p>The configuration of the XMLBean generator is configured in the plugin application context configuration file: <tt>src/main/resources/com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The application context configuration file for the plugin contains the generator bean:</p>
<ul>
<li><tt>xmlBeansDescriptionGenerator</tt> which can describe resolved model entities.</li></ul></div>
<div class="section">
<h4><a name="Model_description_algorithm_in_XmlBeansDescriptionGeneratorImpl">Model description algorithm in XmlBeansDescriptionGeneratorImpl</a> </h4>
<p>The visitor describes a resolved model by creating a single line string description of the the resolved model entity. </p>
<p>The visitor interface defines a <tt>ExecutionResult</tt> as the second parameter:</p>
<div class="source">
<pre>public interface ResolvedModelVisitor
{
    public void visit(ResolvedType resolvedType, ExecutionResult result);
    public void visit(ResolvedObject resolvedObject, ExecutionResult result);
    public void visit(ResolvedEnum resolvedEnum, ExecutionResult result);
    public void visit(ResolvedCollection resolvedCollection, ExecutionResult result);
    public void visit(ResolvedPrimitive resolvedPrimitive, ExecutionResult result);
    public void visit(UnresolvedType unresolved, ExecutionResult result);
    
    // additional methods...
}       
</pre></div>
<p>The second parameter isn't used by the generator, so it accepts null values.</p></div></div>
<div class="section">
<h3><a name="Resolved_model_test_classes">Resolved model test classes</a></h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel.traversal</tt> contains classes which participates in traversal of models with the purpose of testing two models contained by a resolved model:</p>
<ul>
<li><tt>ResolvedModelTesterVisitorImpl</tt> - implementation of the interface <tt>ResolvedModelVisitor</tt> which can test the contents of the two models contained by a resolved model. </li></ul>
<div class="section">
<h4>ResolvedModelTesterVisitorImpl<a name="ResolvedModelTesterVisitorImpl"></a></h4>
<p>Constructor injection is used for dependencies which are used in multiple different configurations. Field injection is used for objects which are doesn't change, i.e. are static. No dependencies is configured using constructor injection.</p></div>
<div class="section">
<h4>Configured ResolvedModelTesterVisitorImpl instance<a name="Configured_ResolvedModelTesterVisitorImpl_instance"></a></h4>
<p>The configuration of the model tester and its dependencies are configured in the plugin application context configuration file: <tt>src/main/resources/com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The application context configuration file for the plugin contains the bean definition:</p>
<ul>
<li><tt>xmlBeansModelTesterVisitor</tt> which can test a resolved model from an XMLBeans model and an MBeans model. </li></ul></div>
<div class="section">
<h4>Model test algorithm in ResolvedModelTesterVisitorImpl <a name="Model_test_algorithm_in_ResolvedModelTesterVisitorImpl"></a></h4>
<p>TODO: write how the commands are used...</p></div></div>
<div class="section">
<h3><a name="Resolved_model_create_classes">Resolved model create classes</a></h3>
<p>The package <tt>com.alpha.pineapple.resolvedmodel.traversal</tt> contains classes which participates in traversal of models with the purpose of creating models contained by a resolved model:</p>
<ul>
<li><tt>MBeansCreatorVisitorImpl</tt> - implementation of the interface <tt>ResolvedModelVisitor</tt> which can create MBeans from the contents of the two models contained by a resolved model. </li></ul>
<div class="section">
<h4>MBeansCreatorVisitorImpl<a name="MBeansCreatorVisitorImpl"></a></h4>
<p>Constructor injection is used for dependencies which are used in multiple different configurations. Field injection is used for objects which are doesn't change, i.e. are static. No dependencies is configured using constructor injection.</p></div>
<div class="section">
<h4>Configured MBeansCreatorVisitorImpl instance<a name="Configured_MBeansCreatorVisitorImpl_instance"></a></h4>
<p>The configuration of the MBeans model creator and its dependencies are configured in the plugin application context configuration file: <tt>src/main/resources/com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The application context configuration file for the plugin contains the bean definition:</p>
<ul>
<li><tt>mbeansModelCreatorVisitor</tt> which can create MBeans from a resolved model.</li></ul></div>
<div class="section">
<h4>Model creation algorithm in MBeansCreatorVisitorImpl <a name="Model_creation_algorithm_in_MBeansCreatorVisitorImpl"></a></h4>
<p>The visitor builds MBeans and set MBean attributes for each resolved model node which is it invoked with. </p>
<p>The next sub sections describes the algorithm for building MBeans when the visitor is visiting an already resolved model object. </p>
<div class="section">
<h5>Model construction from <tt>ResolvedType</tt><a name="Model_construction_from_ResolvedType"></a></h5>
<p>No operation. Null is returned.</p></div>
<div class="section">
<h5>Model construction from <tt>ResolvedObject</tt> <a name="Model_construction_from_ResolvedObject"></a></h5>
<p>The algorithm for creation an MBean from a <tt>ResolvedObject</tt> is:</p>
<ol style="list-style-type: decimal">
<li>Invoke the <tt>CreateMBeanCommand</tt> command. The command creates the MBean in the WebLogic MBean server.</li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedEnum</tt> <a name="Model_construction_from_ResolvedEnum"></a></h5>
<p>The algorithm for creation an MBean from a <tt>ResolvedEnum</tt> is:</p>
<ol style="list-style-type: decimal">
<li>Invoke the <tt>SetMBeanAttributeCommand</tt> command. The command sets the value of the MBean in the WebLogic MBean server.</li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>ResolvedCollection</tt> <a name="Model_construction_from_ResolvedCollection"></a></h5>
<p>No operation. Null is returned.</p></div>
<div class="section">
<h5>Model construction from <tt>ResolvedPrimitive</tt> <a name="Model_construction_from_ResolvedPrimitive"></a></h5>
<p>The algorithm for creation an MBean from a <tt>ResolvedPrimitive</tt> is:</p>
<ol style="list-style-type: decimal">
<li>Invoke the <tt>SetMBeanAttributeCommand</tt> command. The command sets the value of the MBean in the WebLogic MBean server.</li>
<li>Return the execution result.</li></ol></div>
<div class="section">
<h5>Model construction from <tt>UnresolvedType</tt> <a name="Model_construction_from_UnresolvedType"></a></h5>
<p>No operation. Null is returned. </p></div></div></div>
<div class="section">
<h3><a name="Commands">Commands</a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.command</tt> contains Chain commands:</p>
<ul>
<li><tt>CreateMBeanCommand</tt> Creates an MBean from a resolved model object. </li>
<li><tt>SetMBeanAttributeCommand</tt> Sets attribute value on an MBean from a resolved model object. </li>
<li><tt>TestAttributeValueCommand</tt> Test the values of two resolved attributes in a resolved type object. </li>
<li><tt>TestObjectIdentityCommand</tt> Test the values of two resolved objects in a resolved type object </li>
<li><tt>TestCollectionValueCommand</tt> Test the values of two resolved attributes which are known to be collections. </li>
<li><tt>TestEnumValueCommand</tt> Test the values of two resolved attributes which are know to be enums. </li></ul>
<div class="section">
<h4><tt>CreateMBeanCommand</tt><a name="CreateMBeanCommand"></a></h4>
<p>The command creates a new MBean based on this data in the resolved type:</p>
<ul>
<li>Name = secondary participant name.</li>
<li>Type = secondary participant type, e.g. an <tt>MBeanAttributeInfo</tt>.</li>
<li>Parent Object Name = <tt>ObjectName</tt> of parent MBean. </li></ul>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Validate whether the <i>value state</i> of secondary participant is <i>SET</i>. If the value state is set then the command assumes the MBean already exist and will consider the job done. The command will be completed as successful. The command will return the object name of the secondary participant in the context.</li>
<li>Validate whether <i>name</i> of the secondary participant is defined (e.g. isn't null). If the name isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Validate whether <i>type</i> of the secondary participant is defined (e.g. isn't null). If the type isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Validate that the <i>parent</i> is defined (e.g. isn't null). If the parent isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>If the parent is a <i>resolved collection</i> then validate that the <i>grand parent</i> is defined, since it will be used to resolve the parent object name. If the parent is resolved collection and the grand parent isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Validate that the <i>value state</i> of parent secondary participant is <i>SET</i>. If the parent secondary isn't set then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Resolve the <i>object name</i> of the parent MBean. If the parent is a resolved collection the object is resolved from the grand parent. Since collections are presented as a explicit resolved collections, it represents the problem that the parent (i.e. the resolved collection) can't produce a valid object name to invoke the factory method on. If the the (grand)parent secondary value contains a object name then it it used. </li>
<li>Validate that resolved <i>object name</i> is defined (e.g. isn't null). If the object name isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Get type from secondary participant, which is an <tt>AttributeInfo</tt>. If the MBean to be created is a collection entry then the attribute info is inherited from the collection attribute. </li>
<li>Resolves the name of the factory method on parent MBean using the parent object name and the name of the attribute (which is read from the attribute info). The factory method is looked up from the session which contains a repository of MBean meta data from which the factory method name is resolved, the used method is <tt>WeblogicJmxEditSession.getCreateMethod(..)</tt>. </li>
<li>Validate that the returned <tt>MBeanOperationInfo</tt> is defined (e.g. isn't null). If the operation info isn't defined then the command will abort the creation of the MBean. The command will be completed as failed. The command will return a null value in the context.</li>
<li>Invoke the factory method using the session to create the MBean. The factory method returns the object name of the created MBean. The command supports invocation of factory methods with zero or one argument. The name of the secondary participant is used as argument when a one argument factory method is invoked. </li>
<li>Replace the secondary participant with an updated one which contains:
<ul>
<li>Name = Original secondary participant name.</li>
<li>Type = Original secondary participant type, e.g. an <tt>MBeanAttributeInfo</tt>.</li>
<li>Value = <tt>ObjectName</tt> of created MBean.</li></ul></li></ol>
<div class="section">
<h5>Session handling <a name="Session_handling"></a></h5>
<p>It is a precondition for successful execution of the command that the JMX session is in edit mode. The command doesn't validate whether session is in the required state for making changes in the MBeans model. </p>
<p>Also the command doesn't save and activate it's changes.</p>
<p>The reason for this due to the fact the certain attribute can't be set and save before other dependent attributes have been set. To resolved this issue all session handling has been moved to the operation classes. </p></div></div>
<div class="section">
<h4><tt>SetMBeanAttributeCommand</tt> <a name="SetMBeanAttributeCommand"></a></h4>
<p>The command set the value of an MBean attribute based on this data in the resolved type:</p>
<ul>
<li>Name = secondary participant name.</li>
<li>Type = secondary participant type, e.g. an <tt>MBeanAttributeInfo</tt>.</li>
<li>Value = primary participant value. Can be null.</li>
<li>Object Name = The object name is resolved from the value which is contained in the secondary participant in the parent resolved type. The expected type is <tt>ObjectName</tt> . </li></ul>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Validate whether the secondary participant was successfully resolved. If it wasn't successfully resolved (maybe due to fact that the parent MBean wasn't created yet when the models was resolved) then the secondary participant resolved once more to get meta data.</li>
<li>Validate whether <i>name</i> of the secondary participant is defined (e.g. isn't null). If the name isn't defined then the command will abort setting the attribute. The command will be completed as failed.</li>
<li>Validate that the <i>parent</i> is defined (e.g. isn't null). If the parent isn't defined then the command will abort setting the attribute. The command will be completed as failed.</li>
<li>Validate that the <i>value state</i> of parent secondary participant is <i>SET</i>. If the parent secondary isn't set then the command will setting the attribute. The command will be completed as failed.</li>
<li>Get the <i>object name</i> of the MBean from the parent secondary value. </li>
<li>Validate that the <i>object name</i> is defined (e.g. isn't null) and that the type is <tt>ObjectName</tt>. If the object name isn't defined then the command will abort setting the attribute. The command will be completed as failed.</li>
<li>Validate that the the <i>type</i> of the secondary participant is defined (e.g. isn't null) and that the type is <tt>MBeanAttributeInfo</tt>. If the type isn't defined then the command will abort setting the attribute. The command will be completed as failed.</li>
<li>Validate that attribute is defined as <i>writable</i> in the attribute info. If the attribute isn't writable then the command will abort setting the attribute. The command will be completed as failed.</li>
<li>Get the value from the primary participant.</li>
<li>Convert attribute value.
<ol style="list-style-type: decimal">
<li>If the MBean attribute type is <tt>ObjectName</tt> or <tt>ObjectName[]</tt> then the value of the value to be set is treated as a reference or a collection of <tt>ObjectName</tt> references. The references is converted from names to the corresponding <tt>ObjectName</tt>'s in the MBean server through searching. The conversion of references to <tt>ObjectName</tt> is delegated to <tt>WeblogicJMXEditSessionImpl.convertReferenceToObjectNames(..)</tt>.</li>
<li>Otherwise the value is treated as a simple value and it converted to the type of the MBean attribute. </li></ol></li>
<li>Validate whether the value is already set, i.e. exist with the same value on the target MBean. If the value is set then command will skip setting the attribute. The command will be completed as successful.</li>
<li>The value is set on the attribute.</li>
<li>Replace the secondary participant with an updated one which contains:
<ul>
<li>Name = Original secondary participant name.</li>
<li>Type = Original secondary participant type, e.g. an <tt>MBeanAttributeInfo</tt>.</li>
<li>Value = The set value.</li></ul></li></ol>
<div class="section">
<h5>Session handling <a name="Session_handling"></a></h5>
<p>It is a precondition for successful execution of the command that the JXM session is in edit mode. The command doesn't validate whether session is in the required state for make changes in the MBeans model. </p>
<p>Also the command doesn't save and activate it's changes.</p>
<p>The reason for this due to the fact the certain attribute can be set and save before other dependent attributes have been set. To resolved this issue all session handling has been moved to the operation classes. </p></div></div>
<div class="section">
<h4><tt>TestAttributeValueCommand</tt> <a name="TestAttributeValueCommand"></a></h4>
<p>Test the values of two resolved attributes in a resolved type object. The command succeeds if:</p>
<ul>
<li>The value of the two resolved attributes are identical, i.e. passes an <tt>Object.equals(..)</tt> test. Or the value of the two resolved attributes are both null. </li>
<li>Neither of the attributes was resolved unsuccessfully, i.e. none of the resolved attribute must contain an embedded exception. </li></ul></div>
<div class="section">
<h4><tt>TestObjectIdentityCommand</tt> <a name="TestObjectIdentityCommand"></a></h4>
<p>Tests the values of two resolved attributes contained in a resolved type object. The contained values are expected to objects. The command succeeds if:</p>
<ul>
<li>The value of the two resolved attributes are both null. </li>
<li>Neither of the attributes was resolved unsuccessfully, i.e. none of the resolved attribute must contain an embedded exception.</li>
<li>Neither of any child tests failed or completed with an error. The child tests are contained as child execution result objects which exists on the execution result object whihc is passed as input to the test.</li></ul></div>
<div class="section">
<h4><tt>TestCollectionValueCommand</tt> <a name="TestCollectionValueCommand"></a></h4>
<p>Test the values of two resolved attributes in a resolved type object. </p>
<p>The command succeeds if:</p>
<ul>
<li>The type of the resolved type is an <tt>ResolvedCollection</tt>. </li>
<li>The value of the two resolved attributes are both defined, or the value of the two resolved attributes are both null. </li>
<li>If the both values are defined then the length of collections must equal.</li>
<li>Neither of the attributes was resolved unsuccessfully, i.e. none of the resolved attribute must contain an embedded exception.</li>
<li>Neither of any child tests failed or completed with an error. The child tests are contained as child execution result objects which exists on the execution result object which is passed as input to the test. </li></ul></div>
<div class="section">
<h4><tt>TestEnumValueCommand</tt> <a name="TestEnumValueCommand"></a></h4>
<p>Test the values of two resolved attributes in a resolved type object.</p>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Validate the primary participant was resolved successfully. If the participant wasn't successlfully resolved then the command will be completed as failed.</li>
<li>Validate the secondary participant was resolved successfully. If the participant wasn't successlfully resolved then the command will be completed as failed.</li>
<li>Validate the primary participant type is XMLBeans enum, e.g. a type derived from <tt>StringEnumAbstractBase</tt>. If the participant isn't an enum then the command will be completed as failed.</li>
<li>Validate the secondary participant type is a <tt>java.lang.String</tt> or <tt>int</tt>. If the participant isn't a string or int then the command will be completed as failed. </li>
<li>If the secondary type is <tt>int</tt> then the value is converted to a string.</li>
<li>If both values are <tt>null</tt> then the command will be completed as successful. </li>
<li>If only one of the values are <tt>null</tt> then the command will be completed as failed. </li>
<li>If the string value of the first participant is equal to the value of the second participant, i.e. passes an <tt>Object.equals(..)</tt> test then the command will be completed as successful.</li></ol></div></div>
<div class="section">
<h3>XMLBeans model access classes<a name="XMLBeans_model_access_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.model.xmlbeans</tt> contains classes for reflection based access to XMLBean generated model classes:</p>
<ul>
<li><tt>XmlBeansModelResolverImpl</tt></li>
<li><tt>XmlBeansModelAccessorImpl</tt> </li>
<li><tt>XmlBeansGetterMethodMatcherImpl</tt></li>
<li><tt>XmlBeansDescriptionGeneratorImpl</tt> implements the <tt>&lt;ResolvedModelVisitor</tt> interface and it can create a description of an resolved model node.</li></ul>
<div class="section">
<h4><a name="XmlBeansModelResolverImpl">XmlBeansModelResolverImpl</a> </h4>
<p>Implements the <tt>ModelResolver</tt> interface and it is capable of resolving models objects from the XMLBean based model. The important methods are:</p>
<ul>
<li><tt>resolveAttributeNames(ResolvedAttribute attribute )</tt></li>
<li><tt>resolveAttribute( String attributeName, Object modelObject )</tt></li>
<li><tt>resolveCollectionAttributeValues( ResolvedAttribute attribute )</tt></li>
<li><tt>resolveAttributeValue(..)</tt> which can resolve the attribute value for an XMLBean based on the attribute characteristics.</li>
<li><tt>createNonExistingCollectionValue( String id, ResolvedParticipant parent)</tt> which can create a resolved participant placeholder if a collection value isn't defined in a traversed collection. </li>
<li><tt>createResolvedType(ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary)</tt> which can create a resolved model object. </li></ul>
<div class="section">
<h5><a name="Resolution_of_attribute_names_from_an_XMLBean">Resolution of attribute names from an XMLBean</a> </h5>
<p>The method <tt>resolveAttributeNames(ResolvedAttribute attribute )</tt> resolves all the attribute names from an XMLBean. The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Get type from the resolved attribute argument.</li>
<li>Validate that the type is a XMLBeans <tt>SchemaProperty</tt>, if not throw an exception.</li>
<li>Get the <tt>SchemaType</tt> from the <tt>SchemaProperty</tt>.</li>
<li>Get all the properties from <tt>SchemaType</tt></li>
<li>Iterate over the properties:
<ol style="list-style-type: decimal">
<li>Get the name of the property and add it to the result set.</li></ol></li></ol></div>
<div class="section">
<h5><a name="Resolution_of_an_attribute_from_an_XMLBean">Resolution of an attribute from an XMLBean</a> </h5>
<p>The method <tt>resolveAttribute( String attributeName, Object modelObject )</tt> resolve an attribute from a attribute name. If the attribute is resolved then it is returned as a <tt>ResolvedAttribute</tt> object. The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Resolve the getter method from the XMLBean, using the attribute name.</li>
<li>Resolve the type as <tt>SchemaProperty</tt> from XMLBean using the attribute name.</li>
<li>Resolve the value from the XMLBean using the name, type and getter method. </li>
<li>Return the resolved attribute with:
<ul>
<li>name</li>
<li>value</li>
<li>type == the schema property</li>
<li>value state = one of <i>set</i>, <i>default</i>, <i>nil</i>, <i>failed</i>.</li></ul></li></ol></div>
<div class="section">
<h5><a name="Resolution_of_collection_attribute_from_an_XMLBean">Resolution of collection attribute from an XMLBean</a> </h5>
<p>The method <tt>resolveCollectionAttributeValues( ResolvedAttribute attribute )</tt> resolves the value of an resolved participant which represents a value in a collection. The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Get the attribute value as an object array <tt>Object[]</tt>.</li>
<li>Iterate over the object array:
<ol style="list-style-type: decimal">
<li>Create a resolved participant from the current value object, by invoking the private method <tt>resolveSingleArrayAttribute(..)</tt> which does:
<ol style="list-style-type: decimal">
<li>Resolve the attribute type as using <tt>valueObject.getClass()</tt>.</li>
<li>Resolve the attribute name from the value of the <i>Name</i> attribute on the value object.</li>
<li>Return the resolved participant with:
<ul>
<li>name</li>
<li>value</li>
<li>type == type of value object (schema property????!)</li>
<li>value state = <i>SET</i>.</li></ul></li></ol></li>
<li>Add the resolved participant to a hash map....</li></ol></li></ol></div>
<div class="section">
<h5><a name="Creation_of_non_existing_collection_values_from_an_XMLBean">Creation of non existing collection values from an XMLBean</a></h5>
<p>The method <tt>createNonExistingCollectionValue( String id, ResolvedParticipant parent)</tt> can creates a resolved participant placeholder if a collection doesn't contain values which where found in the model that the XMLBeans model is resolved against. </p>
<p>The method is used by model builder visitors, e.g. <tt>ResolvedModelBuilderVisitorImpl</tt> during model construction from a collection. </p>
<p>As described in the section <i>Representation of collections in the resolved model</i> then there is a problem with XMLBeans model because it doesn't define two distinct types for collections. The XMLBeans model only define the type for the unbounded attribute, which is corresponds to the type of the content in the collection. The corresponding schema property contains attributes which signals that type is an unbounded attribute, e.g. an collection. There is a mismatch between the resolved model and the XMLBeans. The problem is that in the XMLBeans schema property based type system there is no explicit representaion of container types. The solution described in the above is to reuse the schema property for BOTH the container type and the content of the collection. </p>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Resolve the type as <tt>SchemaProperty</tt> by using the type from the parent resolved participant which represents a resolved collection.</li>
<li>Resolve the value to null. </li>
<li>Return the resolved attribute with:
<ul>
<li>name = id </li>
<li>value = null</li>
<li>type == the schema property</li>
<li>value state = <i>failed</i>.</li></ul></li></ol></div>
<div class="section">
<h5><a name="Creation_of_resolved_model_objects_during_model_building">Creation of resolved model objects during model building</a> </h5>
<p>The method <tt>createResolvedType(ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary)</tt> can create a resolved model object. The used algorithm is: </p>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>If primary participant type is <b>primitive</b> then:
<ol style="list-style-type: decimal">
<li>Create a <tt>ResolvedPrimitive</tt>.</li></ol></li>
<li>If primary participant type is <b>collection</b> then:
<ol style="list-style-type: decimal">
<li>Create a <tt>ResolvedCollection</tt>.</li></ol>
<p>TODO: There is a bug here!!!! What happens if both types are arrays????</p></li>
<li>If primary participant type is <b>enum</b> then:
<ol style="list-style-type: decimal">
<li>Create a <tt>ResolvedEnum</tt>.</li></ol></li>
<li>If primary participant type is <b>object</b> then:
<ol style="list-style-type: decimal">
<li>Create a <tt>ResolvedObject</tt>.</li></ol></li>
<li>Else create <tt>ResolvedType</tt>.</li>
<li>If an exception is thrown during step 1) - 5) then create <tt>UnresolvedType</tt>.</li></ol></div></div>
<div class="section">
<h4><a name="XmlBeansModelAccessorImpl">XmlBeansModelAccessorImpl</a></h4>
<p>Implements the <tt>XmlBeansModelAccessor</tt> interface and it is capable of accessing model objects generated by XMLBeans. The important methods are:</p>
<ul>
<li><tt>resolveGetterMethod(String attributeName, Object modelObject )</tt></li>
<li><tt>IsPrimitive(ResolvedParticipant)</tt></li>
<li><tt>isEnum(ResolvedParticipant)</tt> </li>
<li><tt>isCollection(ResolvedParticipant, ResolvedParticipant)</tt></li>
<li><tt>isObject(ResolvedParticipant)</tt> </li></ul>
<p>The method <tt>resolveGetterMethod(String attributeName, Object modelObject )</tt> can resolve a single getter method from an attribute name. The used algorithm is:</p>
<ul>
<li>Get all candidates using the getter method matcher <tt>XmlBeansGetterMethodMatcherImpl</tt>, and an attribute name.</li>
<li>Return the first candidate with zero arguments.</li></ul>
<p>The method <tt>isPrimitive(ResolvedParticipant)</tt> return true if:</p>
<ul>
<li>Participant type is <tt>SchemaProperty</tt>.</li>
<li>The schema type contains a simple type ( verified using the method <tt>SchemaType.isSimpleType()</tt> ).</li>
<li>The schema type doesn't contains any enumeration values ( verified using the method <tt>SchemaType.getEnumerationValues()</tt> ).</li></ul>
<p>The method <tt>isEnum(ResolvedParticipant)</tt> return true if:</p>
<ul>
<li>Participant type is <tt>SchemaProperty</tt>.</li>
<li>The schema type contains a simple type ( verified using the method <tt>SchemaType.isSimpleType()</tt> ).</li>
<li>The schema type contains enumeration values ( using the method <tt>SchemaType.getEnumerationValues()</tt> ).</li></ul>
<p>The method <tt>isCollection(ResolvedParticipant parent, ResolvedParticipant child)</tt> return true if:</p>
<ul>
<li>Child participant type is <tt>SchemaProperty</tt>.</li>
<li>Parent participant type is <tt>SchemaProperty</tt>. </li>
<li>The child schema type doesn't contains a simple type ( verified using the method <tt>SchemaType.isSimpleType()</tt> ).</li>
<li>The child schema property represents an array ( verified using the method <tt>SchemaProperty.extendsJavaArray()</tt> ).</li>
<li>The child and parent type isn't equal.</li></ul>
<p>The method <tt>isObject(ResolvedParticipant parent, ResolvedParticipant child)</tt> return true if:</p>
<ul>
<li>Child participant type is <tt>SchemaProperty</tt>.</li>
<li>Parent participant type is <tt>SchemaProperty</tt>. </li>
<li>The schema type contains a complex type ( verified using the method <tt>SchemaType.isSimpleType()</tt> ).</li>
<li>The child schema property doesn't represents an array, e.g. an unbounded type ( verified using the method <tt>SchemaProperty.extendsJavaArray()</tt> ).</li>
<li>The child schema property does represents an array and the child and parent type is equal.</li></ul>
<p><b>Please notice:</b> There is an (ugly) implementation trick at play here. XMLBeans doesn't create an dedicated type to represent collections/array attributes. Collection/array attributes are represented by the type of the collection/array content and then attributes on the <tt>SchemaType</tt> and <b>SchemaProperty</b>&gt; indicated that multiple values can exist for an attributes, i.e. an collection.</p></div>
<div class="section">
<h4><a name="XmlBeansGetterMethodMatcherImpl">XmlBeansGetterMethodMatcherImpl</a> </h4>
<p>Implements the <tt>&lt;GetterMethodMatcher</tt> interface and it can decide whether an method is a getter method. Furthermore it can resolve the attribute name from a matched getter method. </p>
<p>The method <tt>isMatch( Method method )</tt> can resolve whether an method defines a getter method, using the algorithm:</p>
<ul>
<li>The method is declared in a class which belongs to the package <tt>com.oracle.xmlns.weblogic</tt>.</li>
<li>The method starts with <tt>get</tt> and doesn't take any arguments. </li></ul>
<p>The method <tt>resolveAttributeFromGetterMethod</tt> can resolve the attribute name from a method which is known to be a getter method ( i.e. passed the <tt>isMatch(..)</tt> method. The attribute name is resolved using the algorithm:</p>
<ul>
<li>The leading <tt>get</tt> is stripped from the method name.</li>
<li>Any trailing <tt>Array</tt> is stripped from the method name. </li></ul></div>
<div class="section">
<h4><a name="XmlBeansDescriptionGeneratorImpl">XmlBeansDescriptionGeneratorImpl</a> </h4>
<p>Implements the <tt>&lt;ResolvedModelVisitor</tt> interface and it can create a description of an resolved model node.</p></div></div>
<div class="section">
<h3>MBeans model access classes<a name="MBeans_model_access_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.model.mbeans</tt> contains classes for JMX style access to MBean based model (using run time discovery of type info using MBean meta data) classes:</p>
<ul>
<li><tt>MBeansObjectNameBasedModelResolverImpl</tt> implements the <tt>&lt;ModelResolver</tt> interface and it is capable of resolving models objects from the MBean based model.</li>
<li><tt>MBeansModelAccessorImpl</tt></li>
<li><tt>ResolvedModelJmxGetter</tt> - defines interface to for helper class which provides access to data from resolved model objects which is intrepreted as JMX data. </li>
<li><tt>ResolvedModelJmxGetterImpl</tt> - implements the <tt>ResolvedModelJmxGetter</tt> interface. The class is used by command objects which manipulates MBeans.</li>
<li><tt>MBeansDescriptionGeneratorImpl</tt> immplements the <tt>&lt;ResolvedModelVisitor</tt> interface and it can create a description of an resolved model node.</li></ul>
<div class="section">
<h4><a name="MBeansObjectNameBasedModelResolverImpl">MBeansObjectNameBasedModelResolverImpl</a></h4>
<p>Implements the <tt>ModelResolver</tt> interface and it is capable of resolving models objects from the MBean based model. </p>
<div class="section">
<h5><a name="Resolution_of_attribute_names_from_an_MBean">Resolution of attribute names from an MBean</a> </h5>
<p>The method <tt>resolveAttributeNames(ResolvedParticipant attribute )</tt> will throw an <tt>UnsupportedOperationException</tt> if invoked since this operation isn't supported by this class. </p></div>
<div class="section">
<h5><a name="Resolution_of_an_attribute_from_an_MBean">Resolution of an attribute from an MBean</a> </h5>
<p>The method <tt>resolveAttribute( String attributeName, ResolvedParticipant participant )</tt> resolve an attribute from a attribute name. If the attribute is resolved then it is returned as a <tt>ResolvedParticipant</tt> object. The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Validate that the value of the participant is <tt>ObjectName</tt>. If the validation fails then an <tt>ModelValidationFailedException</tt> is thrown.</li>
<li>Query the <tt>WebLogicJmxEditSession</tt> for an <tt>MBeanAttributeInfo</tt> for an attribute with the name <tt>attributeName</tt>. A <b>little bit of magic</b> takes places here, since the session is able to resolve the attribute name from the XMLBeans model into the corresponding name in the MBeans model. The mapping is done through the usage of meta data on the MBean attribute (for more info, see <tt>WebLogicJmxEditSession</tt> ).</li>
<li>Validate that the <tt>MBeanAttributeInfo</tt> isn't null. If the validation fails then an <tt>ModelValidationFailedException</tt> is thrown.</li>
<li>The attribute id is read from the <tt>MBeanAttributeInfo.getName()</tt> </li>
<li>Validate that the value of MBean attribute is readable. If the validation fails then an <tt>ModelValidationFailedException</tt> is thrown.</li>
<li>The attribute value(s) is read from the MBean server.</li>
<li>If the value is a null reference to an object name (e.g. the value is null and the attribute type stored within the <tt>MBeanAttributeInfo</tt> is <tt>ObjectName</tt>) then a <tt>ResolvedParticipant</tt> is created with:
<ul>
<li>id = the id read in step 4.</li>
<li>type = the <tt>MBeanAttributeInfo</tt> from step 2.</li>
<li>value = null </li>
<li>value state = NIL.</li></ul></li>
<li>Otherwise a <tt>ResolvedParticipant</tt> is created with:
<ul>
<li>id = the id read in step 4.</li>
<li>type = the <tt>MBeanAttributeInfo</tt> from step 2.</li>
<li>value = the value(s) read form step 6. </li></ul></li></ol>
<p>If the method <tt>resolveAttribute(..)</tt> fails to resolve an attribute on the MBean then an unsuccessful resolution result is created for the resolved attribute. The unsuccessful result contains an <tt>ModelResolutionFailedException</tt> which describes which attribute failed to be resolved. Known cases:</p></div>
<div class="section">
<h5><a name="Resolution_of_collection_attribute_from_an_MBean">Resolution of collection attribute from an MBean</a> </h5>
<p>The method <tt>resolveCollectionAttributeValues( ResolvedParticipant participant )</tt> resolves the value of an resolved attribute. The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>A <tt>HashMap</tt> is created.</li>
<li>The values is read from the resolved attribute as an array: <tt>Object[]</tt>.</li>
<li>Iteration over the array, where each array value is resolved in turn:
<ol style="list-style-type: decimal">
<li>If the value isn't of the type <tt>ObjectName</tt> then unsuccessful resolution result is created for the resolved value. The unsuccessful result contains an <tt>ModelResolutionFailedException</tt> which describes that the resolution failed because type isn't <tt>ObjectName</tt>. </li>
<li>A <tt>ResolvedParticipant</tt> is created with:
<ul>
<li>id = read from the <tt>Name</tt> attribute of the MBean represented by the array value as <tt>ObjectName</tt>.</li>
<li>type = <tt>ObjectName</tt></li>
<li>value = the array value itself. </li></ul></li>
<li>The resolution result is added to the hash map. </li></ol></li></ol></div>
<div class="section">
<h5><a name="Creation_of_non_existing_collection_values_from_an_XMLBean">Creation of non existing collection values from an XMLBean</a></h5>
<p>The method <tt>createNonExistingCollectionValue( String id, ResolvedParticipant parent)</tt> can creates a resolved participant placeholder if a collection doesn't contain values which where found in the model that the MBeans model is resolved against. </p>
<p>The method is used by model builder visitors, e.g. <tt>ResolvedModelBuilderVisitorImpl</tt> during model construction from a collection. </p>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Resolve the type as the Java Component type from the array returned as the type from the parent resolved collection.</li>
<li>Resolve the value to null. </li>
<li>Return the resolved attribute with:
<ul>
<li>name = id </li>
<li>value = null</li>
<li>type == type (the component type from the array type defined as type for the parent resolved collection.</li>
<li>value state = <i>failed</i>.</li></ul></li></ol></div>
<div class="section">
<h5><a name="Type_resolution_during_model_building">Type resolution during model building</a> </h5>
<p>The method <tt>createResolvedType(ResolvedType parent, ResolvedParticipant primary, ResolvedParticipant secondary)</tt> can create a resolved model object. The MBeans model resolver doesn't implement any algorithms for type resolution and will throw an <tt>UnsupportedOperationException</tt> if invoked. </p></div></div>
<div class="section">
<h4><a name="MBeansModelAccessorImpl">MBeansModelAccessorImpl</a></h4>
<p>Implements the <tt>MBeansModelAccessor</tt> interface and it is capable of getting type information from model objects and retrieve object and attributes from model objects.</p>
<div class="section">
<h5>findAttributeInfo( .. ) method<a name="findAttributeInfo_..__method"></a></h5>
<p>The method can resolve an appropriate <tt>MBeanAttributeInfo</tt> object from a queried attribute name on an MBean (which represented as an <tt>ObjectName</tt>).</p>
<p>The used algorithm is:</p>
<ol style="list-style-type: decimal">
<li>Remap names of certain MBean attributes to handles special cases where getter method otherwise resolution will fail. The mapping is delegated to <tt>SpecialCasesAttributeMapperImpl.mapResolution()</tt>.</li>
<li>Get <tt>MBeanInfo</tt> for MBean.</li>
<li>Get all <tt>MBeanAttributeInfo</tt> from <tt>MBeanInfo</tt>.</li>
<li>Iterate through all info until a match is found with the remapped attribute name. When a match is found then return the found <tt>MBeanAttributeInfo</tt>. Otherwise return null. </li></ol></div>
<div class="section">
<h5>getNameAttributeFromObjName( .. ) method<a name="getNameAttributeFromObjName_..__method"></a></h5>
<p>The method returns the value of the attribute named &quot;Name&quot; from a MBean. </p>
<p>The value is returned as a string. </p></div>
<div class="section">
<h5>getAttributeValue( .. ) method<a name="getAttributeValue_..__method"></a></h5>
<p>The method returns the value of an attribute from a MBean.</p>
<p>The value is returned as a <tt>Object</tt>.</p>
<p>The method <b>doesn't</b>&gt; do any remapping of attribute names. </p></div></div>
<div class="section">
<h4><a name="ResolvedModelJmxGetterImpl">ResolvedModelJmxGetterImpl</a> </h4>
<p>Contains these methods to access resolved model objects to get data which is used to create MBeans:</p>
<ul>
<li><tt>getAttributeID(ResolvedType resolvedType)</tt> resolves a MBean attribute name from the name of the secondary participant in a resolved type. </li>
<li><tt>getAttributeValue(ResolvedType resolvedType)</tt> gets MBean attribute value from from resolved type. The value resolved from the value of the primary participant which is returned as a string object.. </li>
<li><tt>getObjectName(ResolvedType resolvedType)</tt> gets MBean object name. The object name is resolved from object name of the dynamic MBean proxy which is stored in the secondary participant in the parent resolved type.</li>
<li><tt>resolveObjectName(ResolvedType resolvedType)</tt> resolves MBean object name. The object name is resolved from the value contained in the secondary participant in the parent resolved type. If the value contained in the secondary participant is a object namethen it is returned. If the value is a dynamic MBean Proxy then the object name of the proxy is resolved. </li></ul></div>
<div class="section">
<h4><a name="MBeansDescriptionGeneratorImpl">MBeansDescriptionGeneratorImpl</a> </h4>
<p>Implements the <tt>ResolvedModelVisitor</tt> interface and it can create a description of an resolved model node:</p>
<ul>
<li>Values whose type is <tt>null</tt>, the then value-as-single-line-string is returned. </li>
<li>Values whose type is stored as <tt>ObjectName</tt>, which is is the case for the root resolved type since no <tt>MBeanAttributeInfo</tt> exists for the domain. Then the description <tt>NAME:TYPE</tt> is generated. Example: <tt>alphadomain-wls1035-jmxplugin-inttest:Domain</tt>. </li>
<li>Values whose type is stored as <tt>MBeanAttributeInfo</tt> and the type in the info object is <tt>ObjectName</tt> then ...</li>
<li>Values whose type is stored as <tt>MBeanAttributeInfo</tt> and the type in the info object is <tt>ObjectName[]</tt> then ...</li></ul></div></div>
<div class="section">
<h3>MBeans meta data repository classes<a name="MBeans_meta_data_repository_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.model.mbeans.metadata</tt> contains classes for caching MBean meta data and mapping of attribute name from the XMLBeans model to the MBeans model:</p>
<ul>
<li><tt>AttributeMetadata</tt> defines interface for meta data for a single MBean attribute. </li>
<li><tt>AttributeMetadataImpl</tt> implements the <tt>AttributeMetadata</tt> interface. </li>
<li><tt>MBeanMetadata</tt> defines interface for meta data for a single MBean. </li>
<li><tt>MBeanMetadataImpl</tt> implements the <tt>MBeanMetadata</tt> interface. </li>
<li><tt>MetadataRepository</tt> defines interface for repository for MBean meta data. </li>
<li><tt>MetadataRepositoryImpl</tt> implements the <tt>MetadataRepository</tt> interface. </li></ul>
<div class="section">
<h4><a name="MetadataRepositoryImpl">MetadataRepositoryImpl</a></h4>
<p>Defines a repository for storage of meta data about WebLogic MBeans. </p>
<p>The repository stores meta data for each WebLogic MBean type and its attributes. Meta data about MBeans are stored in a map with objects of the type <tt>MBeanMetadata</tt> (implemented by the <tt>MBeanMetadataImpl</tt> class).</p>
<p>Each <tt>MBeanMetadataImpl</tt> contains a map of <tt>AttributeMetadata</tt> (implemented by the <tt>AttributeMetadataImpl</tt> class).</p>
<p>The repository supports:</p>
<ul>
<li><b>Looking up attribute info for an MBean</b> - Implemented by <tt>getAttributeInfo(..)</tt>.</li>
<li><b>Looking up the create method for an MBean</b> - Implemented by <tt>getCreateMethod(..)</tt>.</li>
<li><b>Looking up the destroy method for an MBean</b> - Implemented by <tt>getDestroyMethod(..)</tt>.</li>
<li><b>Resolve candidate MBean types</b> - Implemented by <tt>resolveCandidateReferenceTypes(..)</tt>.</li></ul>
<div class="section">
<h5>Looking up attribute info for an MBean<a name="Looking_up_attribute_info_for_an_MBean"></a></h5>
<p>The method <tt>MBeanAttributeInfo getAttributeInfo(..)</tt> returns the meta data for an MBean attribute.</p>
<p>The method implements a few custom mapping rules:</p>
<ul>
<li>If the attribute name is <tt>VirtualHostName</tt> AND the MBean type is <tt>VirtualHostMBeanImpl&gt;&gt; then the attribute name is mapped to &lt;&lt;&lt;VirtualHostNames</tt> </li></ul></div>
<div class="section">
<h5>Looking up the create method for an MBean<a name="Looking_up_the_create_method_for_an_MBean"></a></h5>
<p>The method <tt>MBeanOperationInfo getCreateMethod(..)</tt> returns the meta data for the create method to create an instance of an MBean type. </p>
<p>The actual resolution is done by looking up the method on the <tt>AttributeMetadata</tt> for the attribute. </p></div>
<div class="section">
<h5>Looking up the destroy method for an MBean <a name="Looking_up_the_destroy_method_for_an_MBean"></a></h5>
<p>The method <tt>MBeanOperationInfo getDestroyMethod(..)</tt> returns the meta data for the destroy method to destroy an instance of an MBean type. </p>
<p>The actual resolution is done by looking up the method on the <tt>AttributeMetadata</tt> for the attribute. </p></div>
<div class="section">
<h5>Resolve candidate MBean types<a name="Resolve_candidate_MBean_types"></a></h5>
<p>The XMLBeans model contains attributes whose value is an MBean reference. For good reason the references in the XMLBeans can't be object name references since the model is text based.</p>
<p>During resolution the textual references are converted from text to object names.</p>
<p>The conversion requires information about which MBean types an attribute can contain a reference to.</p>
<p>The method <tt>String[] resolveCandidateReferenceTypes(..)</tt> supports these conversions:</p>
<ul>
<li>If the attribute name is <tt>Targets</tt> AND the attribute type is an array of MBeans (e.g. <tt>[Ljavax.management.ObjectName;</tt>) then the candidate types are:
<ul>
<li><tt>Cluster</tt> </li>
<li><tt>Server</tt></li></ul></li>
<li>If the attribute name is <tt>Machine</tt> AND the attribute type is a single MBean (e.g. <tt>javax.management.ObjectName</tt>) then the candidate type is:
<ul>
<li><tt>Machine</tt> </li></ul></li></ul></div></div>
<div class="section">
<h4><a name="MBeanMetadataImpl">MBeanMetadataImpl</a></h4>
<p>Contains meta data for a single MBean.</p>
<div class="section">
<h5>Algorithm for storage of attributes<a name="Algorithm_for_storage_of_attributes"></a></h5>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>The attribute is stored in <i>lower case</i> under its name read from the <tt>MbeanAttributeInfo.getName()</tt>.</li>
<li>Get the alternate name (See <a href="./implementation.html#Computation_of_alternate_attribute_name">Algorithm for computation of an alternate name for each attribute</a>).</li>
<li>If the alternate name is null or an empty string:
<ul>
<li>Exit, the attribute isn't stored under an alternate name.</li></ul></li>
<li>If the alternate name is equal to the attribute name:
<ul>
<li>Exit, the attribute isn't stored under an alternate name.</li></ul></li>
<li>If the alternate name isn't already in use:
<ul>
<li>Store the attribute in <i>lower case</i> under the alternate name.</li></ul></li>
<li>If the alternate name is in use:
<ul>
<li>If the name and the alternate name have a common prefix, then overwrite attribute in <i>lower case</i> under the alternate name. </li></ul></li></ol></div>
<div class="section">
<h5>Algorithm for storage of operations<a name="Algorithm_for_storage_of_operations"></a></h5>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>If the operation signature has more than one argument:
<ul>
<li>Exit, the plugin currently only support zero or single argument methods.</li></ul></li>
<li>If no operation is stored with operation name: 
<ul>
<li>Store the operation in using its name as key.</li>
<li>Exit.</li></ul></li>
<li>If the operation signature has more than one argument:
<ul>
<li>Overwrite the existing operation with the one-argument version.</li></ul></li></ol></div></div>
<div class="section">
<h4><a name="AttributeMetadataImpl">AttributeMetadataImpl</a></h4>
<p>Contains meta data for a single MBean attribute:</p>
<ul>
<li><b>Create method</b> - If defined, it defined the method used to create a MBean instance.</li>
<li><b>Destroy method</b> - If defined, it defined the method used to destroy a MBean instance.</li>
<li><b>Name</b> - Unique ID for the MBean. </li>
<li><b>Alternate name</b> - Alternate ID for the MBean, used to map from the XMLBeans models to the MBeans model.</li>
<li><b>Type</b> - In the form of an <tt>MBeanAttributeInfo</tt>.</li></ul>
<div class="section">
<h5>Computation of MBean create method<a name="Computation_of_MBean_create_method"></a></h5>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>The <tt>Descriptor</tt> object defines a field named <tt>com.bea.creator</tt> for MBeans which can be created on demand. The field defines the name of the factory method which should be used to create the MBean, If the field is defined then value will be of the form <tt>createXXX</tt>. </li></ol></div>
<div class="section">
<h5>Computation of MBean destroy method<a name="Computation_of_MBean_destroy_method"></a></h5>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>The <tt>Descriptor</tt> object defines a field named <tt>com.bea.destroyer</tt> for MBeans which can be created on demand. The field defines the name of the destructor method which should be used to destroy the MBean.. If the field is defined then value will be of the form <tt>createXXX</tt>. </li></ol></div>
<div class="section">
<h5>Computation of alternate attribute name<a name="Computation_of_alternate_attribute_name"></a></h5>
<p>The alternate name for an attribute is computed from the content of the <tt>Descriptor</tt> objects found on each <tt>MBeanAttributeInfo</tt>. </p>
<p>The algorithm is:</p>
<ol style="list-style-type: decimal">
<li>The <tt>Descriptor</tt> object defines a field named <tt>com.bea.creator</tt> for MBeans which can be created on demand. The field defines the name of the factory method which should be used to create the MBean (see: <a href="./mbeans-model.html#Creation_and_deletion_of_MBeans_in_WebLogic">Creation and deletion of MBeans in WebLogic</a>). If the field is defined then value will be of the form: <tt>createXXX</tt>. The alternate name is computed as the name of the method without the <tt>create</tt>, e.g. <tt>XXX</tt>.</li>
<li>The <tt>Descriptor</tt> object defines a field named <tt>interfaceclassname</tt> for MBeans which defines an interface class. The field defines the name of the interface class for the MBean, i.e. <tt>[Lweblogic.management.configuration.AppDeploymentMBean;</tt>. If the field is defined then the alternate name is computed as the name of the MBean without the <tt>MBean</tt>, e.g. <tt>AppDeployment</tt>.</li>
<li>If the attribute doesn't have an create method or an interface name then no alternate name is computed. </li></ol></div></div></div>
<div class="section">
<h3>Generic reflection helper classes<a name="Generic_reflection_helper_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.reflection</tt> contains generic reflection helper classes:</p>
<ul>
<li><tt>MethodUtils</tt> - helper class which can get type information from object and invoke methods using reflection.</li></ul>
<p>TODO: MethodUtils.getMethod shouldn't handle the boolean::getXX -&gt; boolean::isXX. this should be located in the get MBeanModelAccessor. </p>
<p>TODO: MethodUtils.isMethodEncrypted should be located in the get XMLBeansModelAccessor. </p>
<p>TODO: MethodUtils.isMethodPasswordEncrypted should be located in the get XMLBeansModelAccessor. </p></div>
<div class="section">
<h3>Generic JMX helper classes<a name="Generic_JMX_helper_classes"></a></h3>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.utils</tt> contains utilities classes for the plugin:</p>
<ul>
<li><tt>JmxUtils</tt> - Utility class for creation of Dynamic proxies and Webogic object names.</li>
<li><tt>JmxServiceUrlFactoryFactory</tt> - Factory which supports resolution of proper service URL factory to be used by a session to connect to a MBean server using a select protocol.</li>
<li><tt>JmxServiceUrlFactory</tt> - Interface for service URL factories which can create JMX service URL and connection properties for a specific protocol.</li>
<li><tt>HttpJmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the Oracle implementation of the HTTP and HTTPS protocols which are supplied with WebLogic.</li>
<li><tt>IiopJmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the Oracle implementation of the IIOP and IIOPS protocols which are supplied with WebLogic.</li>
<li><tt>RmiJmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the Oracle implementation of the RMI protocol which is supplied with WebLogic.</li>
<li><tt>t3jmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the T3 and T3S protocols which are supplied with WebLogic.</li>
<li><tt>JdkIiopJmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the JDK implementation of the IIOP protocol.</li>
<li><tt>jdkRmiJmxServiceUrlFactoryImpl</tt> - Implementation of the <tt>JmxServiceUrlFactory</tt> interface which can create JMX service URL and connection properties for the JDK implementation of the RMI protocol.</li></ul>
<p>The package <tt>com.alpha.pineapple.plugin.weblogic.jmx.management</tt> contains generic JMX helper classes:</p>
<ul>
<li><tt>JMXManagmentException</tt> - exception class for JMX classes in the plugin.</li>
<li><tt>WeblogicJMXNamingUtils</tt> - helper class for creation of MBean object names and MBean type resolution. </li></ul></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span12">Copyright &copy;                   2017.
          All Rights Reserved.      
                    
      </div>

                          
        
                </div>
    </footer>
  </body>
</html>
