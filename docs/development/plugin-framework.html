<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src\site\apt/development\plugin-framework.apt at 03 Mar 2019
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Allan Thrane Andersen" />
    <meta name="Date-Revision-yyyymmdd" content="20190303" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Pineapple Project &#x2013; Plugin framework reference</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script type="text/javascript" src="../js/apache-maven-fluido-1.7.min.js"></script>
    <!-- Google Analytics -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-28287414-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Pineapple Project</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
      <li class=""><a href="../index.html" title="Pineapple Home">Pineapple Home</a><span class="divider">/</span></li>
    <li class="active ">Plugin framework reference</li>
        <li id="publishDate" class="pull-right">Last Published: 03 Mar 2019</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">Project Overview</li>
    <li><a href="../index.html" title="Home"><span class="none"></span>Home</a></li>
    <li><a href="../usage/installation.html" title="Installation"><span class="none"></span>Installation</a></li>
    <li><a href="../usage/index.html" title="For Users"><span class="none"></span>For Users</a></li>
    <li><a href="../development/index.html" title="For Developers"><span class="none"></span>For Developers</a></li>
    <li><a href="../usage/terms.html" title="Terms and Conditions"><span class="none"></span>Terms and Conditions</a></li>
      <li class="nav-header">Clients</li>
    <li><a href="../pineapple-applications/pineapple-web-application/pineapple-standalone-web-client/index.html" title="Standalone Web Application"><span class="none"></span>Standalone Web Application</a></li>
    <li><a href="../pineapple-applications/pineapple-web-application/pineapple-web-application-war/index.html" title="Deployable Web Application"><span class="none"></span>Deployable Web Application</a></li>
    <li><a href="../pineapple-applications/pineapple-maven-plugin/index.html" title="Maven Plugin"><span class="none"></span>Maven Plugin</a></li>
      <li class="nav-header">Plugins</li>
    <li><a href="../pineapple-plugins/pineapple-agent-plugin/index.html" title="Agent"><span class="none"></span>Agent</a></li>
    <li><a href="../pineapple-plugins/pineapple-composite-execution-plugin/index.html" title="Composite Execution"><span class="none"></span>Composite Execution</a></li>
    <li><a href="../pineapple-plugins/pineapple-ssh-plugin/index.html" title="SSH"><span class="none"></span>SSH</a></li>
    <li><a href="../pineapple-plugins/pineapple-docker-plugin/index.html" title="Docker"><span class="none"></span>Docker</a></li>
    <li><a href="../pineapple-modules/pineapple-infrastructure-test-plugin/index.html" title="Infrastructure Test"><span class="none"></span>Infrastructure Test</a></li>
      <li class="nav-header">API's</li>
    <li><a href="../pineapple-applications/pineapple-web-application/pineapple-web-application-war/usage/rest.html" title="REST"><span class="none"></span>REST</a></li>
    <li class="active"><a href="#"><span class="none"></span>Plugin Framework</a></li>
      <li class="nav-header">Additional Information</li>
    <li><a href="http://pineapplesoftware.blogspot.com" class="externalLink" title="The Pineapple Project Blog"><span class="none"></span>The Pineapple Project Blog</a></li>
    <li><a href="http://exceptiontrail.blogspot.com" class="externalLink" title="Pineapple Exception Trail Blog"><span class="none"></span>Pineapple Exception Trail Blog</a></li>
      <li class="nav-header">Project Tools</li>
    <li><a href="https://bintray.com/pineapple/maven/com.alpha.pineapple" class="externalLink" title="Downloads"><span class="none"></span>Downloads</a></li>
    <li><a href="https://github.com/athrane/pineapple" class="externalLink" title="Source Code"><span class="none"></span>Source Code</a></li>
    <li><a href="https://github.com/athrane/pineapple/issues" class="externalLink" title="Issue Tracker"><span class="none"></span>Issue Tracker</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
</ul>
          <hr />
          <div id="poweredBy">
    <script type="text/javascript">asyncJs( 'https://apis.google.com/js/plusone.js' )</script>
    <div class="g-plusone" data-href="https://athrane.github.io/pineapple/" data-size="tall" ></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<div class="section">
<h2><a name="Plugin_framework_reference"></a>Plugin framework reference</h2>
<div class="section">
<h3><a name="Introduction"></a>Introduction</h3>
<p>Pineapple defines a framework for implementation of new plugins. The purpose of the framework is make it possible to extend Pineapple with new functionality. </p>
<div class="section">
<h4><a name="Structure_of_this_document"></a>Structure of this document</h4>
<p>The basics:</p>
<ul>
<li>An introductory example - the hello world plugin.</li>
<li>Plugin class.</li>
<li>Operation classes.</li>
<li>Exception handling in plugins. (TODO)</li></ul>
<p>Advanced features: </p>
<ul>
<li>Enabling input unmarshalling for plugins.</li>
<li>Enabling session handling for plugins. </li>
<li>Using execution results to report how the execution proceeds in details. (TODO) </li>
<li>Inject execution info provider to gain access to execution info.</li>
<li>Inject runtime directory provider to gain access information about used runtime directories. </li>
<li>Using the runtime directory provider to resolve model element paths </li>
<li>Inject administration provider to gain access to administration API.</li>
<li>Inject variable substitution provider resolve variables.</li>
<li>Implement an wild card operation.</li></ul>
<p>Implementation related issues:</p>
<ul>
<li>Enabling annotation based dependency injection in Spring</li>
<li>Implementing internationalization (I18N) support in plugins</li>
<li>Writing testable operation classes </li>
<li>Implement plugins using command objects. (TODO)</li>
<li>Setting up a Maven project for plugin development. (TODO)</li>
<li>Known issues </li></ul></div></div>
<div class="section">
<h3><a name="An_introductory_example"></a>An introductory example </h3>
<p>A plugin can written with two classes: </p>
<ul>
<li>The plugin class.</li>
<li>A class implementing an operation. </li></ul>
<p>First, the plugin class:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.helloworld;

import com.alpha.pineapple.plugin.Plugin;

@Plugin() 
public class PluginImpl {}
</pre></div>
<p>..and the operation class:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.helloworld;

import com.alpha.pineapple.plugin.Operation;
import com.alpha.pineapple.plugin.PluginOperation;
import com.alpha.pineapple.session.Session;

@PluginOperation(&quot;hello-world&quot;) 
public class HelloWorldOperation implements Operation {

  public void execute(Object content, Session session, ExecutionResult result) throws PluginExecutionFailedException {
        System.out.println(&quot;Hello world&quot;);
}
</pre></div></div>
<div class="section">
<h3><a name="The_plugin_class"></a>The plugin class</h3>
<div class="section">
<h4><a name="Purpose_of_the_plugin_class"></a>Purpose of the plugin class</h4>
<p>The purpose of the plugin class is to <i>define meta data</i> about a plugin. The plugin class implicit defines the plugin id which is the most important meta data attribute for a plugin. It will later be described how the plugin class can be used to explicit define additional meta data attributes to control <i>input unmarshalling</i> for a plugin. </p></div>
<div class="section">
<h4><a name="The_plugin_id"></a>The plugin id </h4>
<p>The plugin id is defined as the Java package where the plugin class is located in. The plugin class for the hello world plugin shown above, is located in the package <tt>com.alpha.pineapple.plugin.helloworld</tt>. As a result the plugin id for hello world plugin is <tt>com.alpha.pineapple.plugin.helloworld</tt>. </p>
<p>The plugin id must be unique for each plugin and only a single plugin class is allowed to be implemented in each package.</p>
<p>The plugin id used in the environment configuration to defined which plugin a resource is bound to at runtime. The plugin id is defined as part of the definition of a resource. The plugin id is defined in the resource attribute named <tt>plugin</tt>. For information on definition of resources, refer to the <a href="../usage/configuration-environment.html">Environment configuration reference.</a></p></div>
<div class="section">
<h4><a name="Implementation_of_a_plugin_class"></a>Implementation of a plugin class </h4>
<p>A plugin class is implemented by creating a class and annotating it with the <tt>@Plugin</tt> annotation. </p>
<p><b>Example:</b> The plugin class for the Pineapple WebLogic JMX plugin (with plugin id = com.alpha.pineapple.plugin.weblogic.jmx) is implemented as: </p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.weblogic.jmx;

import com.alpha.pineapple.plugin.Plugin;

@Plugin()
public class PluginImpl {}
</pre></div>
<p>As the plugin class only serves to define meta data there is no requirements or need for implementation of any interfaces or methods. </p></div>
<div class="section">
<h4><a name="Finding_plugins_a_runtime"></a>Finding plugins a runtime</h4>
<p>When Pineapple is started it scans the entire class path for classes which are annotated with the <tt>@Plugin</tt> annotation. If an annotated class is found then Pineapple registers the plugin and starts to scan the package (and sub packages) where the plugin class is found for operation classes. This results in a small overhead at startup but it eliminates the need for configuration files which configures plugins. For information on what happens during Pineapple startup, refer to the <a href="../pineapple-modules/pineapple-core/development/initialization.html"> Initialization of the core component.</a></p></div></div>
<div class="section">
<h3><a name="Operation_classes"></a>Operation classes </h3>
<div class="section">
<h4><a name="Purpose_of_a_operation_class"></a>Purpose of a operation class</h4>
<p>The purpose of a operation class is to <i>implement a single Pineapple operation</i> in a plugin. A plugin implements an operation class for each supported operation. Pineapple can be used to execute operations of any name and each plugin only implements operation classes for each of operations that it wishes to support. </p></div>
<div class="section">
<h4><a name="Implementation_of_a_operation_class"></a>Implementation of a operation class</h4>
<p>Steps required to implement an operation class:</p>
<ul>
<li>The operation class must be located i the same package (or sub packages) as the plugin class.</li>
<li>The class must implement the <tt>Operation</tt> interface.</li>
<li>The class must be annotated with the <tt>@PluginOperation</tt> annotation. </li>
<li>The <tt>@PluginOperation</tt> annotation must be defined with a unique id which defines the name of operation that the operation class implements. The id must unique within that package (or sub packages) defined by the plugin class.</li></ul>
<div class="section">
<h5><a name="Location_of_operation_classes"></a>Location of operation classes</h5>
<p>The operation class must be located i the same package (or sub packages) as the plugin class. Pineapple considers the package where the plugin class is found as the root package of the plugin. Pineapple will limit its search to the root package and sub packages for operations classes. </p></div></div>
<div class="section">
<h4><a name="The_Operation_interface"></a>The <tt>Operation</tt> interface</h4>
<p>The <tt>Operation</tt> interface is defined as:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin;

import com.alpha.pineapple.session.Session;

public interface Operation {
        
  public void execute( Object content, Session session, ExecutionResult result ) throws PluginExecutionFailedException;
        
}       
</pre></div>
<p>The interface contains a single <tt>execute(Object content, Session session, ExecutionResult result)</tt> method which will invoked by Pineapple at runtime if the environment configuration and the module given as input to the operation specifies it. The arguments values will contain:</p>
<ul>
<li>The <tt>content</tt> argument is typed <tt>java.lang.Object</tt>. If <i>input unmarshalling</i> (described below) is configured for the plugin then it will contain the root of the object graph which is unmarshalled from the module model given as input to the operation. If <i>input marshalling</i> isn't configured then argument will be null. </li>
<li>If <i>session handling</i> (also described below) is configured for the plugin then the <tt>session</tt> argument will contain a configured session object which can used to access the entity which is managed by the plugin. If <i>session handling</i> isn't configured then argument will contain a null session object. </li>
<li>The <tt>result</tt> argument contains an execution result object which is used to describe how the execution of the operation proceeds. The object is created by Pineapple before the operation is invoked. The operation can use the execution result to add additional runtime information about the operation and add child execution result objects which describes the outcome of its execution in more detail.</li></ul>
<p>The concepts of <i>input unmarshalling</i> and <i>session handling</i> for plugins are described in details below. </p></div>
<div class="section">
<h4><a name="The_operation_id"></a>The operation id</h4>
<p>An operation class must be annotated with the <tt>@PluginOperation</tt> annotation, which defines a single meta data attribute: <i>the operation id</i>. The operation id defines which the operation class implements. The operation id must be unique within the root package (or sub packages) defined by the plugin class. If multiple operations is found with an identical id then Pineapple's plugin scan fails. The <tt>@PluginOperation</tt> doesn't define any default values, so a value is mandatory. Null values isn't allowed, operations with a null or empty id are discarded when Pineapple scans for plugins. </p>
<p>TODO: handle multiple identical operation ids</p>
<p>TODO: handle empty operation id</p>
<p>TODO: handle null operation id</p>
<p><b>Example:</b> The skeletion of the operation class for the Pineapple WebLogic JMX plugin,which is defined with the operation id <i>deploy-configuration</i> : </p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.weblogic.jmx.operation;

import com.alpha.pineapple.plugin.Operation;
import com.alpha.pineapple.plugin.PluginOperation;

@PluginOperation(&quot;deploy-configuration&quot;)
public class DeployConfiguration implements Operation
{
  public void execute( Object content, Session session ) throws PluginExecutionFailedException
  {
    // logic goes here..    
  }
}
</pre></div></div>
<div class="section">
<h4><a name="Handling_unsupported_operations"></a>Handling unsupported operations</h4>
<p>If a plugin is invoked with a operation that it doesn't support then Pineapple delegates the execution to a null operation. The result is that in practice a plugin doesn't need to implement any operations at all. A plugin without any operations wouldn't be of any use. </p>
<p>TODO: implement. </p></div></div>
<div class="section">
<h3><a name="Exception_handling_in_plugins"></a>Exception handling in plugins</h3>
<p>There are two places to implement exception handling in plugins:</p>
<ul>
<li>Operations classes</li>
<li>Session classes.</li></ul>
<div class="section">
<h4><a name="Exception_handling_in_operation_classes"></a>Exception handling in operation classes</h4>
<p>..there are two ways to handle exceptions in operations; .. 1) catch and update the execution result .. 2) throw an PluginExecutionFailedException and let Pineapple catch and update the execution result</p>
<div class="section">
<h5><a name="catch_and_update_the_execution_result"></a>catch and update the execution result</h5>
<p>..the preferred way to handle exceptions in operations is to catch them within the operation code and update the execution result accordingly.</p></div>
<div class="section">
<h5><a name="throw_an_PluginExecutionFailedException_and...."></a>throw an PluginExecutionFailedException and....</h5>
<p>..the operation interface defines trowing of PluginExecutionFailedException in the execute method, so an operation could throw an exception of this type an error occours. ..the throw execution will be caught by Pineapple and used to determine update the state of the execution result object for the operation. A thrown exection will result in a execution state == failed. ..the detais of the thrown execption, e.g. error message and stack trace, will be added as detail to the execution result object for operation:</p>
<div class="source"><pre class="prettyprint linenums">
        catch ( Exception e )
        {
                Object[] args = { StackTraceHelper.getStrackTrace( e ) };                       
                String message = messageProvider.getMessage(&quot;to.error&quot;, args );
            throw new PluginExecutionFailedException( message, e );
        }

</pre></div></div></div>
<div class="section">
<h4><a name="Exception_handling_in_session_classes"></a>Exception handling in session classes</h4>
<p>The Session interface defines two methods which throws typed exceptions:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.session;

public interface Session
{
  public void connect(Resource resource, Credential credential) throws SessionConnectException;   
  public void disconnect() throws SessionDisconnectException;
}
</pre></div>
<p>The <tt>connect(..)</tt> methods should throw a <tt>SessionConnectException</tt> when establishing a connecting to a resource fails.</p>
<p>The <tt>disconnect(..)</tt> methods should throw a <tt>SessionDisconnectException</tt> when terminating a connection to a resource fails.</p>
<p>If a plugin extends the <tt>Session</tt> interface then added methods should throw <tt>SessionException</tt> to signal errors during operation of a connected session.</p></div>
<div class="section">
<h4><a name="The_exception_hierarchy"></a>The exception hierarchy </h4>
<p>..PluginException is the root exception for plugins..</p>
<p>..PluginExecutionFailedException and PluginInitializationFailedException are subclasses of PluginException.</p>
<p>..PluginInitializationFailedException is thrown internal by Pineapple when plugin activation and invocation fails. </p></div></div>
<div class="section">
<h3><a name="Enabling_input_unmarshalling_for_plugins"></a>Enabling input unmarshalling for plugins </h3>
<p><i>Input unmarshalling</i> is the process of binding schema-based XML from a module model file to objects and delivering the objects to an invoked operation class. For information on module models, refer to the <a href="../usage/configuration-modules.html">Module configuration reference.</a> </p>
<div class="section">
<h4><a name="Define_the_plugin_schema"></a>Define the plugin schema </h4>
<p>The first step is to define the data model for the plugin. The model is defined in XML schema. The schema can either be defined as part of the implementation of the plugin or an existing shcema can be used.</p>
<div class="section">
<h5><a name="Recommended_plugin_schema_namespace"></a>Recommended plugin schema namespace</h5>
<p>The recommended namespace for plugin is: </p>
<p><tt>http://pineapple.dev.java.net/ns/plugin/${plugin-name}</tt> where ${plugin-name} is substituted with the plugin name.</p>
<p><tt>Example:</tt> The namespace for the infrastructure plugin is <tt>http://pineapple.dev.java.net/ns/plugin/infrastructure_1_0</tt> </p>
<p><tt>Example:</tt> The Weblogic JMX plugin uses a schema which was defined by BEA (r.i.p.). The namespace of this schema is <tt>http://www.bea.com/ns/weblogic/920/domain</tt> </p></div></div>
<div class="section">
<h4><a name="Define_OXM_binding_from_schema_to_objects"></a>Define OXM binding from schema to objects</h4>
<p>A XML binding technology such a JAXB or XMLBeans should be used to generate the model classes. The model classes should be in included in the plugin build. </p>
<p>If the plugin schema is defined as part of the plugin then it is.... TODO: write...</p>
<p>If the model classes already exists because the an existing schema is used, then reference the classes in the Maven build to ensure that they are included in the build.</p></div>
<div class="section">
<h4><a name="Unmarshalling_is_based_on_Spring-OXM"></a>Unmarshalling is based on Spring-OXM </h4>
<p>Pineapple uses the OXM (object-to-XML) portion of the Spring framewok for unmarshalling of schema-based module models in XML file to objects. Spring-OXM is used because it provide a unifying interface for accessing different OXM frameworks. The core part of the Spring-OXM framework is the <tt>Marshaller</tt> and <tt>Unmarshaller</tt> interface. Pineapple uses the <tt>Unmarshaller</tt> interface for binding XML to objects. For information on Spring OXM, refer to the <a class="externalLink" href="http://static.springframework.org/spring-ws/sites/1.5/reference/html/oxm.html">Spring OXM site.</a> </p></div>
<div class="section">
<h4><a name="Configuring_unmarshalling_on_the_plugin_class"></a>Configuring unmarshalling on the plugin class </h4>
<p>Input unmarshalling is configured on the <tt>@Plugin</tt> annotation on a plugin class. The <tt>@Plugin</tt> annotation supports two optional meta data attributes for configuring input unmarshalling: </p>
<ul>
<li><tt>configFile</tt></li>
<li><tt>unmarshaller</tt> </li></ul>
<p>The two attributes is used in conjuction to setup unmarshalling.</p></div>
<div class="section">
<h4><a name="The_configFile_attribute"></a>The <tt>configFile</tt> attribute </h4>
<p>Defines the name of an XML file which contain the definition of a Spring application context. The purpose of the application context is to configure a Spring-OXM unmarshaller. When Pineapple is started it will attempt to load the file from the classpath, so any path information in the attribute must be relative to the classpath.</p>
<p><b>Example</b>: The plugin class for the blue dream plugin defines a value for the <tt>configFile</tt> attribute:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.bluedream;

import com.alpha.pineapple.plugin.Plugin;

@Plugin(configFile=&quot;dreaming-context.xml&quot;, unmarshaller=&quot;blueUnmarshaller&quot;)
public class PluginImpl {}      
</pre></div>
<p>..during startup Pineapple will attempt to load the configuration file named <tt>dreaming-context.xml</tt> from the root of the classpath. </p>
<div class="section">
<h5><a name="Recommended_default_value_is_.24pluginId-config.xml"></a>Recommended default value is <tt>$<a name="pluginId">pluginId</a>-config.xml</tt> </h5>
<p>If no value is provided for the <tt>configFile</tt> attribute then the default value is used: <tt>${pluginId}-config.xml</tt>. The ${pluginId} is the plugin id from plugin class, i.e. the package where the plugin class is located in. It is recommended to use the default value. </p>
<p>If the recommended default value is used, then the <tt>${pluginId}-config.xml</tt> file should be placed in the <tt>src/resources</tt> folder of the Maven project which implements the plugin.</p>
<p><b>Example</b>: The plugin class for the Pineapple WebLogic JMX plugin doesn't explicitly define a value for the <tt>configFile</tt> attribute: </p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.weblogic.jmx;

import com.alpha.pineapple.plugin.Plugin;

@Plugin()
public class PluginImpl {}      
</pre></div>
<p>..instead Pineapple will use the default value <tt>com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. </p></div>
<div class="section">
<h5><a name="Unmarshalling_is_disabled_if_configuration_file_can.27t_found"></a>Unmarshalling is disabled if configuration file can't found </h5>
<p>If Pineapple can't find the configuration file with the application context then marshalling is disabled and the operation is invoked with a null value.</p>
<p>Refering back to the initial hello world example, it didn't define any Spring configuration file for unmarshalling, so it that case the input unmarshalling was disabled. </p>
<p>TODO: implement. </p></div></div>
<div class="section">
<h4><a name="The_unmarshaller_attribute"></a>The <tt>unmarshaller</tt> attribute</h4>
<p>The <tt>unmarshaller</tt> attribute on the <tt>@Plugin</tt> annotation defines the id of the unmarshaller in the Spring application context which should used to unmarshall the module model XML to objects. The Spring application context was previously defined by the <tt>configFile</tt> attribute. Pineapple will look up a marshaller with the id defined by the <tt>unmarshaller</tt> attribute and then use the returned unmarshaller object to unmarshall the XML at hand. </p>
<p>TODO: handle if no bean is found</p>
<p>TODO: handle if found bean isnt a marshaller</p>
<p><b>Example</b>: The plugin class for the blue dream plugin defines a value for the <tt>unmarshaller</tt> attribute:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.bluedream;

import com.alpha.pineapple.plugin.Plugin;

@Plugin(configFile=&quot;dreaming-context.xml&quot;, unmarshaller=&quot;blueUnmarshaller&quot;)
public class PluginImpl {}      
</pre></div>
<p>..during startup Pineapple will load the configuration file named <tt>dreaming-context.xml</tt> and use the unmarshaller named <tt>blueUnmarshaller</tt> in the application context. </p>
<div class="section">
<h5><a name="Recommended_default_value_is_unmarshaller"></a>Recommended default value is <tt>unmarshaller</tt> </h5>
<p>If no value is provided for the <tt>unmarshaller</tt> attribute then the default value is used: <tt>unmarshaller</tt>. It is recommended to use the default value.</p>
<p><b>Example</b>: The plugin class for the Pineapple WebLogic JMX plugin doesn't explicitly define a value for the <tt>unmarshaller</tt> attribute:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.weblogic.jmx;

import com.alpha.pineapple.plugin.Plugin;

@Plugin()
public class PluginImpl {}      
</pre></div>
<p>..instead Pineapple will use the default value <tt>unmarshaller</tt> to look for a unmarshaller in the Spring application context.</p></div></div>
<div class="section">
<h4><a name="Writting_the_Spring_configuration_file_for_the_plugin"></a>Writting the Spring configuration file for the plugin </h4>
<p>The purpose of the configuration file is to define a unmarshaller bean. The id of the unmarshaller must correspond to the value of the unmarshaller attribute in the <tt>@Plugin</tt> annotation. </p>
<div class="section">
<h5><a name="Spring_schemas"></a>Spring schemas</h5>
<p>Use the Spring schema and the Spring-OXM schema to write the configuration file. The used schemas are:</p>
<ul>
<li>Spring: http://www.springframework.org/schema/beans</li>
<li>Spring-OXM: http://www.springframework.org/schema/oxm</li></ul>
<p>The minimal configuration file without a unmashaller definition looks like: </p>
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;
      
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot; &gt;       
        
  &lt;!-- insert unmarshaller definition here --&gt;  
            
&lt;/beans&gt;        
</pre></div>
<p>TODO: upgrade the spring-context-2.5.xsd (Spring 3.0.0.M3) to spring-context-3.0.xsd when it is fixed in Spring 3.0.0. </p></div></div>
<div class="section">
<h4><a name="Using_Spring-OXM_with_JAXB2"></a>Using Spring-OXM with JAXB2 </h4>
<p>To define a unmarshaller, add the stanza: </p>
<div class="source"><pre class="prettyprint linenums">  &lt;oxm:jaxb2-marshaller id=&quot;unmarshaller&quot; contextPath=&quot;com.alpha.pineapple.plugin.infrastructure.model&quot;/&gt;
</pre></div>
<p>where the value if the <tt>id</tt> attribute must match the value of the <tt>unmarshaller</tt> in the <tt>@Plugin</tt> annotation. The value of <tt>contextPath</tt> attribute should match the package name which contains the model classes used by the plugin and which should be unmarshalled.</p>
<p><b>Example</b>: The plugin infrastructure test plugin uses JABX for unmarshalling. The model classses for the plugin are located in the package <tt>com.alpha.pineapple.plugin.infrastructure.model</tt>. The configuration looks like:</p>
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;

    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
      http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot; &gt;     

        &lt;oxm:jaxb2-marshaller id=&quot;unmarshaller&quot; contextPath=&quot;com.alpha.pineapple.plugin.infrastructure.model&quot;/&gt;     
&lt;/beans&gt;        
</pre></div></div>
<div class="section">
<h4><a name="Using_Spring-OXM_with_XMLBeans"></a>Using Spring-OXM with XMLBeans</h4>
<p>To define a unmarshaller, add the stanza:</p>
<div class="source"><pre class="prettyprint linenums">  &lt;oxm:xmlbeans-marshaller id=&quot;unmarshaller&quot;/&gt;
</pre></div>
<p>where the value if the <tt>id</tt> attribute must match the value of the <tt>unmarshaller</tt> in the <tt>@Plugin</tt> annotation. </p>
<p><b>Example</b>: The application context file for the Pineapple WebLogic JMX plugin is named <tt>com.alpha.pineapple.plugin.weblogic.jmx-config.xml</tt>. The plugin uses XMLBeans for unmarshalling, so the configuration file contains the definition of a <tt>xmlbeans-unmarshaller</tt> with the id <tt>unmarshaller</tt>: </p>
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;
    
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot; &gt;       

  &lt;oxm:xmlbeans-marshaller id=&quot;unmarshaller&quot;/&gt;
            
&lt;/beans&gt;        
</pre></div>
<p><b>Example #2</b>: The plugin class for the blue dream plugin is defined as: </p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.bluedream;

import com.alpha.pineapple.plugin.Plugin;

@Plugin(configFile=&quot;dreaming-context.xml&quot;, unmarshaller=&quot;blueUnmarshaller&quot;)
public class PluginImpl {}      
</pre></div>
<p>..which configures Pineapple to look for a configuration file named <tt>dreaming-context.xml</tt>. The configuration file contains: </p>
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;
    
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot; &gt;       

  &lt;oxm:xmlbeans-marshaller id=&quot;blueUnmarshaller&quot;/&gt;
            
&lt;/beans&gt;        
</pre></div>
<p>..after the file is loaded, Pineapple will use the unmarshaller named <tt>blueUnmarshaller</tt> based on the value of the <tt>unmarshaller</tt> attribute from the <tt>@Plugin</tt> annotation. </p></div></div>
<div class="section">
<h3><a name="Enabling_session_handling_for_plugins"></a>Enabling session handling for plugins </h3>
<p><i>Session handling</i> is the process using a session object to connect to a remote device accessed by a plugin. So, if a plugin needs to connect to a remote device then a plugin must implement a session class. </p>
<div class="section">
<h4><a name="Implementation_of_a_session_class"></a>Implementation of a session class</h4>
<p>Steps required to implement an session class:</p>
<ul>
<li>Extend the <tt>com.alpha.pineapple.Session</tt> interface with the additional methods required by the operation classes. </li>
<li>Implement the session class by implementing the extened session interface.</li>
<li>The session class must be located i the same package (or sub packages) as the plugin class.</li>
<li>It must be annotated with the <tt>com.alpha.pineapple.plugin.PluginSession</tt> annotation. </li></ul></div>
<div class="section">
<h4><a name="The_Session_interface"></a>The <tt>Session</tt> interface</h4>
<p>Plugins use the <tt>com.alpha.pineapple.session.Session</tt> interface to implement session handling code:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.session;

import com.alpha.pineapple.model.configuration.Credential;
import com.alpha.pineapple.model.configuration.Resource;

public interface Session
{
  public void connect(Resource resource, Credential credential) throws SessionConnectException;   
  public void disconnect() throws SessionDisconnectException;
}
</pre></div>
<p>The interface should be extended if the operation classes in the plugin need additional methods to communicate which the session.</p></div>
<div class="section">
<h4><a name="The_PluginSession_annotation"></a>The <tt>PluginSession</tt> annotation</h4>
<p>The purpose of the <tt>@PluginSession</tt> annotation it mark the class as the session class which should be used by the plugin for session handling. </p></div>
<div class="section">
<h4><a name="Usage_of_the_session_class_in_operation_classes"></a>Usage of the session class in operation classes</h4>
<p>Prior to invoking an operation, Pineapple will create a session instance and connect to the targeted resource using the <tt>connect(..)</tt> method on the session. The point is that a operation class will only be invoked will a connected session. </p>
<p>If connecting/disconnecting fails, Pineapple contain <b><a href="../pineapple-modules/pineapple-core/usage/session-retry-support.html">session retry logic</a></b> which will retry to connect/disconnect a session several times prior to failing.</p></div>
<div class="section">
<h4><a name="Operation_classes_should_never_invoke_connection_methods_on_sessions"></a>Operation classes should never invoke connection methods on sessions </h4>
<p>The <tt>connect(..)</tt> method is invoked by Pineapple prior to injecting the session object into an operation.</p>
<p>The <tt>disconnect(..)</tt> method is invoked by Pineapple after execution of the operation into which the session was injected.</p>
<p>An operation class should never invoke the <tt>connect(..)</tt> and the <tt>disconnect()</tt> methods of the session object.</p>
<p>It is fine to invoke all other methods to use the session logic in implemented in the session class. </p></div>
<div class="section">
<h4><a name="Operation_classes_which_requires_access_to_the_resource_and_credetial_used_to_initialize_the_session"></a>Operation classes which requires access to the resource and credetial used to initialize the session</h4>
<p>Plugin operations can get access to the resource or crdential objects which is used to initialize the sessions in two ways:</p>
<ul>
<li>Provide <tt>Session</tt> implementation in the plugin and configure the plugin to use session handling. The session interface provides getters to access the resource and the credential.</li>
<li>Extend the <tt>DefaultSessionImpl</tt> class, and include it in the plugin and configure the plugin to use session handling. The session interface provides getters to access the resource and the credential. </li></ul></div>
<div class="section">
<h4><a name="Value_of_the_session_parameter_in_operations_in_plugins_which_doesn.27t_support_session_handling"></a>Value of the session parameter in operations in plugins which doesn't support session handling</h4>
<p>If the plugin doesn't define session handling then the <tt>session</tt> parameter in the <tt>execute(...)</tt> method will invoked with a null session object which implements the <tt>Session</tt> interface. </p>
<p>Currently Pineapple will use the class <tt>NullSessionImpl</tt> but this is subject to change. </p></div></div>
<div class="section">
<h3><a name="Using_execution_results_to_report_how_the_execution_proceeds_in_details"></a>Using execution results to report how the execution proceeds in details</h3>
<div class="section">
<h4><a name="Operation_class_is_invoked_with_an_execution_result"></a>Operation class is invoked with an execution result</h4>
<p>When an operation is invoked with <tt>public void execute( Object content, Session session, ExecutionResult result)</tt> then result contains an execution result object which is created by Pineapple with the state:</p>
<ul>
<li>ExecutionState = <tt>Running</tt></li>
<li>Description = <tt>Module model on target resource....</tt></li></ul></div>
<div class="section">
<h4><a name="Operation_class_is_responsible_for_setting_the_final_execution_state"></a>Operation class is responsible for setting the final execution state</h4>
<p>It is the responsibility of the operation class to set the execution state prior to completing its execution:</p>
<div class="section">
<h5><a name="Simple_operations_should_set_the_state_explict"></a>Simple operations should set the state explict</h5>
<p>If the operation is an simple operation which doesn't invokes any commands then the operation should explicit set the state to either <i>successful</i>, <i>failed</i>, or <i>error</i> illustrated by this code fragment:</p>
<div class="source"><pre class="prettyprint linenums">        
  try {         
        
    if (somethingImportantSucceeeded) {

      // set successful result
      executionResult.setState(ExecutionState.SUCCESS);     
        
      // create message
      Object[] args = { this.hostname, this.ip };
      String message = messageSource.getMessage(&quot;operation_i18n_id.succeed&quot;, args, null );              
      executionResult.addMessage(&quot;Message&quot;, message );   
        
      return;                                   
    }
            
    // set failed result
    executionResult.setState(ExecutionState.FAILURE);        

    // create message                     
    String message = messageSource.getMessage(&quot;operation_i18n_id.failed&quot;, null, null );              
    executionResult.addMessage(&quot;Message&quot;, message );                                                        

  } catch ( SomeException e ) {

    // set result with error
    executionResult.setState(ExecutionState.ERROR);

    // create messages                                  
    executionResult.addMessage(&quot;Message&quot;, messageSource.getMessage(&quot;operation_i18n_id.error&quot;, args, null ) );           
    executionResult.addMessage(&quot;StackTrace&quot;, StackTraceHelper.getStrackTrace( e ));             
  }             
        
</pre></div></div>
<div class="section">
<h5><a name="Composite_operations_can_use_the_computed_state"></a>Composite operations can use the computed state</h5>
<p>If the operation is implemented using command which add child execution result objects to the execution result supplied by Pineapple, then the operation can set the state using the <i>computed</i> as illustrated by the code fragment:</p>
<div class="source"><pre class="prettyprint linenums">
  // compute execution state from children
  executionResult.setState(ExecutionState.COMPUTED);

  // declare message 
  String message;

  // handle test outcome
  if (executionResult.getState() == ExecutionState.SUCCESS ) {
    message = messageSource.getMessage(&quot;operation_i18n_id.completed&quot;, null, null );
  } else {
    ExecutionResult[] failedTests = executionResult.getChildrenWithState( ExecutionState.FAILURE );
    ExecutionResult[] errorTests = executionResult.getChildrenWithState( ExecutionState.ERROR );
    Object[] args = { failedTests.length, errorTests.length };                          
    message = messageSource.getMessage(&quot;operation_i18n_id.failed&quot;, args, null );
  }

  // store the message        
  executionResult.addMessage(&quot;Message&quot;, message );    

</pre></div></div></div>
<div class="section">
<h4><a name="Pineapple_throws_an_exception_if_an_operation_dosen.27t_sets_its_execution_state"></a>Pineapple throws an exception if an operation dosen't sets its execution state</h4>
<p>When the invocation of <tt>public void execute( Object content, Session session, ExecutionResult result)</tt> returns then Pineapple validates that the execution result isn't <i>running</i>. If the state is still <i>running</i> then Pinapple sets the state as <i>failed</i> with the message <i>Operation failed.......</i>. TODO: implement.. </p></div></div>
<div class="section">
<h3><a name="Inject_execution_info_provider_to_gain_access_to_execution_info"></a>Inject execution info provider to gain access to execution info</h3>
<p>This feature requires the <a href="#Enabling_annotation_based_dependency_injection_in_Spring">Enabling annotation based dependency injection in Spring</a> to be enabled first. </p>
<p>An operation can gain access to a <tt>ExecutionInfo</tt> object which contains runtime information about the operation and the module. Two steps are required to implement access to the execution info object in an operation:</p>
<p>First, define a dependency injected field in the operation class:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Execution info provider.
     */
    @Resource
    ExecutionInfoProvider coreExecutionInfoProvider;
</pre></div>
<p>or alternatively:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Execution info provider.
     */
    @Resource(name=&quot;coreExecutionInfoProvider&quot; )
    ExecutionInfoProvider executionInfoProvider;
</pre></div>
<p>Second, resolve the execution info object at runtime using the execution result object for the operation as key:</p>
<div class="source"><pre class="prettyprint linenums">
    // lookup execution info
    ExecutionInfo info = coreExecutionInfoProvider.get(result);

</pre></div>
<div class="section">
<h4><a name="The_name_.22coreExecutionInfoProvider.22_is_reserved_in_plugin_application_contexts"></a>The name &quot;coreExecutionInfoProvider&quot; is reserved in plugin application contexts</h4>
<p>The execution info provider object is resolved from the name <tt>coreExecutionInfoProvider</tt>. </p>
<p>The name <tt>coreExecutionInfoProvider</tt> is reserved by Pineapple in plugin application contexts. If an plugin defines a bean with this name then the definition will overridden at runtime by Pineapple and the bean will be resolved to the execution info provider object instead.</p></div></div>
<div class="section">
<h3><a name="Inject_runtime_directory_provider_to_gain_access_information_about_used_runtime_directories"></a>Inject runtime directory provider to gain access information about used runtime directories</h3>
<p>This feature requires the <a href="#Enabling_annotation_based_dependency_injection_in_Spring">Enabling annotation based dependency injection in Spring</a> to be enabled first. </p>
<p>An operation can gain access to a <tt>RuntimeDirectoryProvider</tt> object which contains runtime information about which runtime directories Pineapple is using. One step is required to implement access to the provider object in an operation:</p>
<p>First, define a dependency injected field in the operation class:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Runtime directory provider.
     */
    @Resource
    RuntimeDirectoryProvider coreRuntimeDirectoryProvider;
</pre></div>
<p>or alternatively:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Runtime directory provider.
     */
    @Resource(name=&quot;coreRuntimeDirectoryProvider&quot; )
    RuntimeDirectoryProvider provider;
</pre></div>
<p>Use the provider at runtime:</p>
<div class="source"><pre class="prettyprint linenums">    // get modules directory
    File modulesDirectory = coreRuntimeDirectoryProvider.getModulesDirectory();
</pre></div>
<div class="section">
<h4><a name="The_name_.22coreRuntimeDirectoryProvider.22_is_reserved_in_plugin_application_contexts"></a>The name &quot;coreRuntimeDirectoryProvider&quot; is reserved in plugin application contexts</h4>
<p>The runtime directory provider object is resolved from the name <tt>coreRuntimeDirectoryProvider</tt>. </p>
<p>The name <tt>coreRuntimeDirectoryProvider</tt> is reserved by Pineapple in plugin application contexts. If an plugin defines a bean with this name then the definition will overridden at runtime by Pineapple and the bean will be resolved to the runtime directory provider object instead.</p></div></div>
<div class="section">
<h3><a name="Using_the_runtime_directory_provider_to_resolve_model_element_paths"></a>Using the runtime directory provider to resolve model element paths </h3>
<p>A <i>model element path</i> (MEP) is a path definition which occurs in a module model which defines directories or files to be processed as part of the execution of an operation.</p>
<div class="section">
<h4><a name="Model_element_path_to_identify_files_within_the_current_module"></a>Model element path to identify files within the current module</h4>
<p>To support <i>location independent</i> model element paths, plugins can choose to support the <tt>modulepath:</tt> path prefix, which enabled users of plugin to define path such as:</p>
<div class="source"><pre class="prettyprint linenums">    &lt;some-path&gt;modulepath:some/resource/path/myfile.txt&lt;/some-path&gt;
</pre></div>
<p>The runtime directory provider interface <tt>RuntimeDirectoryProvider</tt> provides two methods which can be used by plugins to resolve model element paths:</p>
<div class="source"><pre class="prettyprint linenums">    File resolvModelElementPath(String path, ModuleInfo info);  
    boolean startsWithModulePathPrefix(String path);
</pre></div>
<p>If <tt>resolvModelElementPath</tt> is invoked with a path with starts with <i>modulepath:</i> then the path is resolved to <tt>${pineapple-home-directory}\modules\${current-module-directory}\${remaining-path}</tt>. </p>
<p>Example: If the module <tt>alpha-module</tt> is located physically at:</p>
<div class="source"><pre class="prettyprint linenums">    c:/pineapple/modules/alpha-module
</pre></div>
<p>and some model within the module contains the path:</p>
<div class="source"><pre class="prettyprint linenums">    modulepath:some/resource/path/myfile.txt
</pre></div>
<p>then during execution of the module, the path will be resolved to:</p>
<div class="source"><pre class="prettyprint linenums">    c:/pineapple/modules/alpha-module/some/resource/path/myfile.txt
</pre></div></div>
<div class="section">
<h4><a name="Model_element_path_to_identify_files_within_the_another_module"></a>Model element path to identify files within the another module</h4>
<p>To support <i>location independent</i> module element paths, plugins can choose to support the <tt>moduleroot:</tt> path prefix, which enabled users of plugin to define path such as:</p>
<div class="source"><pre class="prettyprint linenums">    &lt;some-path&gt;moduleroot:some-module&lt;/some-path&gt;
</pre></div>
<p>This allows one module to reference another module in a location independent way.</p>
<p>The runtime directory provider interface <tt>RuntimeDirectoryProvider</tt> provides two methods which can be used by plugins to resolve model element paths:</p>
<div class="source"><pre class="prettyprint linenums">    File resolvModelElementPath(String path, ModuleInfo info);  
    boolean startsWithModuleRootPrefix(String path);
</pre></div>
<p>If <tt>resolvModelElementPath</tt> is invoked with a path with starts with <i>moduleroot:</i> then the path is resolved to <tt>${pineapple-home-directory}\modules\${some-module}</tt>. </p>
<p>Example: If the module <tt>alpha-module</tt> is located physically at:</p>
<div class="source"><pre class="prettyprint linenums">    c:/pineapple/modules/alpha-module
</pre></div>
<p>And the another module, named <tt>beta-module</tt> contain a model with the path:</p>
<div class="source"><pre class="prettyprint linenums">    moduleroot:alpha-module
</pre></div>
<p>then during execution of <tt>beta-module</tt> the path will be be resolved to:</p>
<div class="source"><pre class="prettyprint linenums">    c:/pineapple/modules/alpha-module
</pre></div></div></div>
<div class="section">
<h3><a name="Inject_administration_provider_to_gain_access_to_administration_API"></a>Inject administration provider to gain access to administration API</h3>
<p>This feature requires the <a href="#Enabling_annotation_based_dependency_injection_in_Spring">Enabling annotation based dependency injection in Spring</a> to be enabled first. </p>
<p>An operation can gain access to a <tt>AdministrationProvider</tt> object which provides access to runtime administration of the core component. Two steps are required to implement access to the provider in an operation:</p>
<p>First, define a dependency injected field in the operation class:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Administration provider.
     */
    @Resource
    AdministrationProvider coreAdministrationProvider;
</pre></div>
<p>or alternatively:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Administration provider.
     */
    @Resource(name=&quot;coreAdministrationProvider&quot; )
    AdministrationProvider administrationProvider;
</pre></div>
<p>Use the provider at runtime:</p>
<div class="source"><pre class="prettyprint linenums">    // get resource repository 
    ResourceRepository resourceRepository = coreAdministrationProvider.getResourceRepository();
</pre></div>
<div class="section">
<h4><a name="The_name_.22coreAdministrationProvider.22_is_reserved_in_plugin_application_contexts"></a>The name &quot;coreAdministrationProvider&quot; is reserved in plugin application contexts</h4>
<p>The administration provider object is resolved from the name <tt>coreAdministrationProvider</tt>. </p>
<p>The name <tt>coreAdministrationProvider</tt> is reserved by Pineapple in plugin application contexts. If an plugin defines a bean with this name then the definition will overridden at runtime by Pineapple and the bean will be resolved to the administration provider object instead.</p></div></div>
<div class="section">
<h3><a name="Inject_variable_substitution_provider_resolve_variables"></a>Inject variable substitution provider resolve variables</h3>
<p>This feature requires the <a href="#Enabling_annotation_based_dependency_injection_in_Spring">Enabling annotation based dependency injection in Spring</a> to be enabled first. </p>
<p>An operation can gain access to a <tt>VariablesubstitutionProvider</tt> object which support substittion of variables from multitple source into text or files. Two steps are required to implement access to the provider in an operation:</p>
<p>First, define a dependency injected field in the operation class:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Variable substitution provider.
     */
    @Resource                
    VariableSubstitutionProvider coreVariableSubstitutionProvider;
</pre></div>
<p>or alternatively:</p>
<div class="source"><pre class="prettyprint linenums">    /**
     * Administration provider.
     */
    @Resource(name=&quot;coreVariableSubstitutionProvider&quot; )
    VariableSubstitutionProvider variableSubstitutionProvider;
</pre></div>
<p>Use the provider at runtime to resolve variables:</p>
<div class="source"><pre class="prettyprint linenums">    String processed = coreVariableSubstitutionProvider.substitute(source, session, result);
</pre></div>
<p>Or create a new (temporary file) with variables processed:</p>
<div class="source"><pre class="prettyprint linenums">    File processedFile = coreVariableSubstitutionProvider.createSubstitutedFile(sourceFile, session, result);
</pre></div>
<p>If the provider is invoked with a session as argument then the provider will resolve the variables from the properties defined on the resource that the session is created. </p>
<p>When an operation targetes multiple resources (through a list or a regular expression) then Pineapple will iterate over the resources and execute the plugin for each target resource. If the the pluign substitutes text or files using the session-resource-properties as input then each artifact will have the variables substituted in from that particular set of session-resource-properties. The result is that each artifact will have a different substituted in depending on the value of the variable in each resource. </p>
<div class="section">
<h4><a name="The_name_.22coreVariableSubstitutionProvider.22_is_reserved_in_plugin_application_contexts"></a>The name &quot;coreVariableSubstitutionProvider&quot; is reserved in plugin application contexts</h4>
<p>The variable substitution provider object is resolved from the name <tt>coreVariableSubstitutionProvider</tt>. </p>
<p>The name <tt>coreVariableSubstitutionProvider</tt> is reserved by Pineapple in plugin application contexts. If an plugin defines a bean with this name then the definition will overridden at runtime by Pineapple and the bean will be resolved to the variable substitution provider object instead.</p></div></div>
<div class="section">
<h3><a name="Implement_an_wild_card_operation"></a>Implement an wild card operation</h3>
<p>An operation can annotated with the <b>*</b> operation ID which defines an wild card operation:</p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.something.operation;

import com.alpha.pineapple.plugin.Operation;
import com.alpha.pineapple.plugin.PluginOperation;

@PluginOperation(&quot;*&quot;)
public class DefaultOperation implements Operation
{
  public void execute( Object content, Session session ) throws PluginExecutionFailedException
  {
      result.setState(ExecutionState.SUCCESS); // complete as success                
  }
}
</pre></div>
<p>When a plugin is invoked and it implements an operation with the wild card operation ID, then Pineapple will resolve any operation to the wild operation. The result is that the plugin supports any operation that Pineapple might be invoked with.</p>
<p>There is one exception. If a plugin implements one operation for operation &quot;A&quot; and an operation with the wild card operation ID &quot;*&quot;: </p>
<div class="source"><pre class="prettyprint linenums">package com.alpha.pineapple.plugin.something.operation;

import com.alpha.pineapple.plugin.Operation;
import com.alpha.pineapple.plugin.PluginOperation;

@PluginOperation(&quot;*&quot;)
public class WildcardOperationImpl implements Operation
{
  public void execute( Object content, Session session ) throws PluginExecutionFailedException
  {
      system.out.println(&quot;Operation *&quot;;
      result.setState(ExecutionState.SUCCESS); // complete as success                
  }
}

@PluginOperation(&quot;A&quot;)
public class OperationAImpl implements Operation
{
  public void execute( Object content, Session session ) throws PluginExecutionFailedException
  {
      system.out.println(&quot;Operation A&quot;;
      result.setState(ExecutionState.SUCCESS); // complete as success                
  }
}

</pre></div>
<p>When Pineapple is invoked with operation &quot;A&quot; then it will resolve the operation to &quot;A&quot;, e.g. <tt>OperationAImpl</tt> in the example code above and print &quot;Operation A&quot;. The named operation takes presence over the the wild card operation. </p>
<p>If Pineapple is invoked with any other operation, e.g. &quot;ljewhf&quot; or &quot;test&quot; or.., then it will resolve the operation to &quot;*&quot;, e.g. <tt>WildcardOperationImpl</tt> in the example code above and print &quot;Operation *&quot;. </p></div>
<div class="section">
<h3><a name="Enabling_annotation_based_dependency_injection_in_Spring">Enabling annotation based dependency injection in Spring</a></h3>
<p>Support for pojo in the plugin to use Springs annotation based dependency injection:</p>
<div class="source"><pre class="prettyprint linenums">
    /**
     * Message source I18N support.
     */
    @Resource
    MessageSource messageSource;

</pre></div>
<p>..can be implemented by:</p>
<ul>
<li>Add Spring dependency.</li>
<li>Add JSR 250 dependency.</li>
<li>Define a <tt>annotation-config</tt> tag in the Spring configuration file for the plugin.</li>
<li>Implement class fields in pojos </li></ul>
<div class="section">
<h4><a name="Add_Spring_dependency"></a>Add Spring dependency </h4>
<p>The configuration of annotation based dependency injection is defined in the Spring context project, so add this dependency to the plugin project:</p>
<div class="source"><pre class="prettyprint linenums">  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;org.springframework.context&lt;/artifactId&gt;
  &lt;/dependency&gt;                                   
</pre></div></div>
<div class="section">
<h4><a name="Add_JSR-250_dependency"></a>Add JSR-250 dependency</h4>
<p>The configuration of the @Resource annotation is defined in the JSR-250 api project, so add this dependency to the plugin project:</p>
<div class="source"><pre class="prettyprint linenums">  &lt;dependency&gt;
    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;                 
  &lt;/dependency&gt;                                 
</pre></div></div>
<div class="section">
<h4><a name="Define_a_annotation-config_tag_in_the_Spring_configuration_file_for_the_plugin"></a>Define a <tt>annotation-config</tt> tag in the Spring configuration file for the plugin</h4>
<p>Add the context schema header to the plugin configuration file:</p>
<ul>
<li>Define namespace for the context schema: <tt>xmlns:context=&quot;http://www.springframework.org/schema/context</tt></li>
<li>Define schema location for the context schema: <tt>xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</tt></li></ul>
<p>Example:</p>
<div class="source"><pre class="prettyprint linenums">
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                http://www.springframework.org/schema/oxm 
                http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd
                http://www.springframework.org/schema/context 
                http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot; &gt;


&lt;/beans&gt;                        
</pre></div>
<p>Add tag to enabled annotation dependency injection when Spring initializes the context:</p>
<div class="source"><pre class="prettyprint linenums">  &lt;!-- enable annotation based configuration / dependency injection --&gt;
  &lt;context:annotation-config /&gt;
</pre></div></div>
<div class="section">
<h4><a name="Implement_class_fields_in_pojos"></a>Implement class fields in pojos </h4></div></div>
<div class="section">
<h3><a name="Implementing_internationalization_.28I18N.29_support_in_plugins"></a>Implementing internationalization (I18N) support in plugins </h3>
<p>Support for internationalization (I18N) can be implemented using interfaces and classes from the <tt>pineapple-api</tt> project by:</p>
<ul>
<li>Add Maven dependency to plugin project</li>
<li>Define a message file for the plugin.</li>
<li>Define a <tt>messageProvider</tt> bean in the Spring configuration file for the plugin.</li>
<li>Define a field in each class which need access to the message provider.</li>
<li>Resolve messages at runtime from the messages file.</li></ul>
<div class="section">
<h4><a name="Add_Maven_dependency_to_plugin_project"></a>Add Maven dependency to plugin project</h4>
<p>The I18N classes are defined in the <tt>pineapple-api</tt> project, and any plugin project will define a dependency to the API project because this project also contains the plugin interfaces and annotations. Verify that this Maven dependency to the api project is defined in the plugin project POM:</p>
<div class="source"><pre class="prettyprint linenums">  &lt;dependency&gt;
    &lt;groupId&gt;com.alpha.pineapple&lt;/groupId&gt;
    &lt;artifactId&gt;pineapple-api&lt;/artifactId&gt;                       
  &lt;/dependency&gt;                         
</pre></div></div>
<div class="section">
<h4><a name="Define_a_message_file_for_the_plugin"></a>Define a message file for the plugin</h4>
<p>Create a text file in the Maven project which contains the messages for the plugin. </p>
<div class="section">
<h5><a name="Recommended_location_for_the_messages_file_src.2Fmain.2Fresources"></a>Recommended location for the messages file <tt>src/main/resources</tt></h5>
<p>Place the message file in the directory <tt>src/main/resources</tt> in the plugin project.</p></div>
<div class="section">
<h5><a name="Recommended_file_name_is_.24.7BpluginId.7D-messages.xml"></a>Recommended file name is <tt>${pluginId}-messages.xml</tt> </h5>
<p>Name the message file <tt>${pluginId}-messages.properties</tt> where ${pluginId} is the plugin id from plugin class, i.e. the package where the plugin class is located in.</p>
<p><b>Example</b>: The message file for infrastructure test plugin is <tt>com.alpha.pineapple.plugin.net-messages.properties</tt>.</p></div></div>
<div class="section">
<h4><a name="Define_a_messageProvider_bean_in_the_Spring_configuration_file_for_the_plugin"></a>Define a <tt>messageProvider</tt> bean in the Spring configuration file for the plugin</h4>
<p>If the plugin contain a Spring configuration file for definition of the unmarshaller bean used for for <i>input unmarshalling</i> then add an additional bean definition to the configuration file which defines the message provider:</p>
<p>Example:</p>
<div class="source"><pre class="prettyprint linenums">        &lt;!-- define message provider for internationalization  --&gt;
        &lt;bean id=&quot;messageProvider&quot; class=&quot;com.alpha.pineapple.i18n.PropertyFileMessageProviderImpl&quot;&gt;
        &lt;property name=&quot;basename&quot; value=&quot;com.alpha.pineapple.plugin.net-messages&quot;/&gt;
        &lt;/bean&gt; 
</pre></div>
<p>The id of the bean should be <tt>messageProvider</tt>.</p></div>
<div class="section">
<h4><a name="Handling_plugins_who_doesn.27t_support_input_marshalling"></a>Handling plugins who doesn't support input marshalling </h4>
<p>If the plugin doesn't support input marshalling then the plugin class doesn't define the attribute the <tt>configFile</tt> and <tt>unmarshaller</tt> on <tt>@Plugin</tt> annotation.</p>
<p>In this situation add the <tt>configFile</tt> attribute to the <tt>@Plugin</tt> annotation and use the application context file to define a message provider bean for the plugin which can be injected into all objects which are part of the plugin. </p></div>
<div class="section">
<h4><a name="Message_provider_implementation_is_PropertyFileMessageProviderImpl"></a>Message provider implementation is <tt>PropertyFileMessageProviderImpl</tt> </h4>
<p>Pineapple only support a single implementation of the <tt>MessageProvider</tt> interface which is named <tt>com.alpha.pineapple.i18n.PropertyFileMessageProviderImpl</tt>.</p>
<p>The <tt>PropertyFileMessageProviderImpl</tt> class supports usage of dots in the name of message file. This enables usage of the naming scheme with the plugin id for message file: <tt>${pluginId}-messages.properties</tt>.</p></div>
<div class="section">
<h4><a name="Define_a_field_in_each_class_which_need_access_to_the_message_provider"></a>Define a field in each class which need access to the message provider</h4>
<p>To get access to the message provider bean from a class in the plugin, declare a field in a class and let Spring inject the message provider when the class is initialized.</p>
<p>Example:</p>
<div class="source"><pre class="prettyprint linenums">
    /**
     * Message provider I18N support.
     */
    @Resource
    MessageProvider messageProvider;
        
</pre></div></div>
<div class="section">
<h4><a name="Resolve_messages_at_runtime_from_the_messages_file"></a>Resolve messages at runtime from the messages file</h4>
<p>To use the message provider, first define a key-value pair in the message file:</p>
<p>Example: <tt>com.alpha.pineapple.plugin.net-messages.properties</tt> contains:</p>
<div class="source"><pre class="prettyprint linenums">
good_message=This a good message from [{0}] and [{1}].
        
</pre></div>
<p>And resolve the message in the class:</p>
<div class="source"><pre class="prettyprint linenums">
        // log debug message
        if ( logger.isDebugEnabled() )
        {
                Object[] args = { &quot;Titus&quot;, &quot;Ed Chianese&quot; };
                String message = messageProvider.getMessage(&quot;good_message&quot;, args );
                logger.debug(message);
        }                        
        
</pre></div></div></div>
<div class="section">
<h3><a name="Writing_testable_operation_classes"></a>Writing testable operation classes </h3>
<div class="section">
<h4><a name="The_operation_no-arg_constructor_is_registered_during_Pineapple_initialization"></a>The operation no-arg constructor is registered during Pineapple initialization </h4>
<p>During initialization of a plugin, the operation classes are located using the component scanning from in the Spring framework. Pineapple will register each operation with its no-arg constructor.</p></div>
<div class="section">
<h4><a name="Make_operation_classes_dependency_injection_enabled_using_field_injection"></a>Make operation classes dependency injection enabled using field injection </h4>
<p>Pineapple only uses the no-arg construction on operation classes to create instances. Implement operation classes which support dependency injection by annotating the fields on operation classes with the <tt>@Resource</tt> annotation. </p>
<p>Dependent objects will then be injected at runtime doing either:</p>
<ul>
<li>Declaring the dependent objects as bean definitions in the plugin application context file.</li>
<li>Enabling component-scan in the plugin application context. </li></ul></div>
<div class="section">
<h4><a name="Integration_testable"></a>Integration testable</h4>
<p>Pineapple is using the no-arg constructor to create operation objects, so it is perfered to implement dependency injection using annotated fields.</p>
<p>Implement integration tests by using:</p>
<ul>
<li>The Spring <tt>@RunWith</tt> annotation.</li>
<li>The Spring <tt>@ContextConfiguration</tt> annotation. </li>
<li>Define the object under test (i.e the operation) as a field annoteated with @Resource on the test class.</li></ul>
<p>Example:</p>
<div class="source"><pre class="prettyprint linenums">
@RunWith( SpringJUnit4ClassRunner.class )
@ContextConfiguration( locations = { &quot;/com.alpha.pineapple.plugin.weblogic.jmx-test-config.xml&quot; } )
public class TestDeployedConfigurationTest
{

    /**
     * Object under test
     */
    @Resource
    TestDeployedConfiguration operation;

    @Before
    public void setUp() throws Exception
    {
    }

    @After
    public void tearDown() throws Exception
    {
    }

    /**
     * Test that TestDeployedConfiguration can be looked up from the context.
     */
    @Test
    public void testCanGetTestDeployedConfigurationFromContext()
    {
        assertNotNull( operation );
    }
        
}                 
</pre></div>
<p>For info about setting up integration test projects refer to, <a href="../pineapple-modules/pineapple-test-utils/examples/writing-integration-test-html">How-to: Write integration tests in Pineapple.</a></p></div>
<div class="section">
<h4><a name="Unit_testable"></a>Unit testable</h4>
<div class="section">
<h5><a name="Provde_N-arg_constructor_for_dependency_injection"></a>Provde N-arg constructor for dependency injection</h5>
<p>Provide a N-arg constructor which can be used to inject mock objects into the operation instance.</p></div>
<div class="section">
<h5><a name="Using_Spring.27s_ReflectionTestUtils_to_do_field_injection"></a>Using Spring's ReflectionTestUtils to do field injection</h5>
<p>Use the <tt>org.springframework.test.util.ReflectionTestUtils</tt> to inject mock object into the operation fields. </p></div></div></div>
<div class="section">
<h3><a name="Known_issues"></a>Known issues</h3>
<div class="section">
<h4><a name="JAXB2_unmharshalls_attribute_to_null_values"></a>JAXB2 unmharshalls attribute to null values</h4>
<p>When using JAXB2 for unmarshalling, JAXB2 doens't unmarshall attribute values correctly. The objects are initialized with null or default values.</p>
<p>This issue can be avoided by setting the schema attribute <tt>attributeFormDefault=&quot;unqualified&quot;</tt> as shown: </p>
<div class="source"><pre class="prettyprint linenums">&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; 
                   xmlns=&quot;http://pineapple.dev.java.net/ns/plugin/infrastructure_1_0&quot; 
                   targetNamespace=&quot;http://pineapple.dev.java.net/ns/plugin/infrastructure_1_0&quot; 
                   elementFormDefault=&quot;qualified&quot; 
                   attributeFormDefault=&quot;unqualified&quot;&gt;
           

</pre></div></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
Copyright (C) 2007-2017 Allan Thrane Andersen. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
